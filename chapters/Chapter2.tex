% !Mode:: "TeX:UTF-8"

\chapter{理论基础和相关的技术}
本章介绍分布式数据库方面的相关理论和技术，还有mysql协议的研究和学习。
\section{数据库的分类和架构}
\subsection{键值存储数据库}
键值数据库就类似传统语言中使用的哈希表。可以通过key来添加、查
询或者删除数据库，因为使用key主键访问，所以会获得很高的性能及扩展性。

键值数据库主要使用一个哈希表，这个表中有一个特定的键和一个指针
指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署、高并发。

典型产品：Memcached、Redis、MemcacheDB。
\subsection{列存储数据库}
列存储数据库将数据存储在列族中，一个列族存储经常被一起查询的相关数据，
比如人类，我们经常会查询某个人的姓名和年龄，而不是薪资。这种情况下姓
名和年龄会被放到一个列族中，薪资会被放到另一个列族中。

这种数据库通常用来应对分布式存储海量数据。

典型产品：Cassandra、HBase。
\subsection{面向文档数据库}
文档型数据库的灵感是来自于Lotus Notes办公软件，
而且它同第一种键值数据库类似。该
类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数
据库可以看作是键值数据库的升级版，允许之间嵌套键值。而
且文档型数据库比键值数据库的查询效率更高。

面向文档数据库会将数据以文档形式存储。每个文档都是自包含的
数据单元，是一系列数
据项的集合。每个数据项都有一个名词与对应值，值既可以是简单的
数据类型，如字符串、
数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数
据存储的最小单位
是文档，同一个表中存储的文档属性可以是不同的，数据可以使用X
ML、JSON或JSONB等多种形式存储。

典型产品：MongoDB、CouchDB。
\subsection{图形数据库}
图形数据库允许我们将数据以图的方式存储。实体会被作为顶点，而实体之
间的关系则会被
作为边。比如我们有三个实体，Steve Jobs、Apple和Next，则会有两个“F
ounded by”的边将Apple和Next连接到Steve Jobs。

典型产品：Neo4J、InforGri。
\subsection{关系型数据库}
虽然网状数据库和层次数据库已经很好的解决了数据的集中和共享问题，但是在数
据库独立性和抽象级别上仍有很大欠缺。用户在对这两种数据库进行存取时
，仍然需要明确数据
的存储结构，指出存取路径。而关系型数据库就可以较好的解决这些问题。

关系型数据库模型是把复杂的数据结构归结为简单的二元关系。
在关系型数
据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分
类、合并、连接或选取等运算来实现数据库的管理。

关系型数据库诞生40多年了，从理论产生发展到现实产品，例如：Oracle和MySQL，O
racle在数据库领域上升到霸主地位，形成每年高达数百亿美元的庞大产业市场。
\subsection{Mysql数据库体系结构}
因为 MySQL 采用的是客户机/服务器体系结构，所以在使用 MySQL 进行存取数据操作
时，必须至少使用两个或者是两类程序：
一个是位于存放数据的主机上的程序——数据库服务器。数据库服务器在网络上
监听来自客户机的请求，然后根据客户机的这些请求访问数据库数据，访问之后再向客户
机提供它们想得到的信息;
连接到数据库服务器的程序——客户机，这些程序是作为用户和服务器之间交互
信息的工具，并且告诉服务器需要查询信息的内容。

MySQL 的架构可以描述为层次性子系统组合。MySQL 的源代码不是按照单组件或者
模块的方式编写的，但是各个层次的源代码还是能够被分离出来，大部分的子系统依赖于
一些通用的底层库。MySQL 包含以下子系统：
网络连接和网络通信协议子系统；
线程、进
程和内存分配子系统；
查询解析和查询优化子系统；存储引擎接口子系统；各类存储引擎
子系统；安全管理子系统；日志子系统；mysql核心库文件等。

当一个客户端通过网络连接 MySQL 数据库服务时，网络连接子系统执行一系列的与网
络协议有关的底层任务。然后网络连接子系统将控制权交给线程子系统，线程子系统提供
一个线程来处理这个连接，这个连接称之为连接线程。随后连接线程得到控制权，它首先
调用安全管理子系统来验证用户访问的合法性。
连接线程将获得的数据传给控制系统，其中一些请求在内核代码中被称作命令。这些
命令中的一部分可以由这个控制系统直接完成，对于不可以直接由系统分发来完成查询的，
分发系统将调用解析子系统对 SQL 语句进行解析。同时，如果在配置 MySQL 系统时采用
了日志功能，那么分发系统还会调用日志系统去记录此次的信息。随后解析子系统将解析
结果传给调用优化子系统以优化 SQL 语句。接着进行表操作，并将一系列请求发往存储引
擎接口子系统。存储引擎接口子系统将上述调用自动转化为某个具体的存储子系统方法。
上述过程完成后，相应的模块将 SQL 执行结果发往客户端，最后再由服务器将控制权交给
连接线程，连接线程完成某些清理工作，并在此等待客户端的连接或者其他查询，直到客
户端输入 Quit 命令为止，到此本次通话才会结束。
\section{关系数据模型}
分布式关系数据库提供基于关系数据模型的数据存储。关系数据模型是三大
数据模型里研究最为成熟，应用最为广泛的数据模型，其他两个分别是层次数据
模型和网状数据模型。数据模型是现实世界数据特征的抽象，用于描述一组数据
的概念和定义。数据库的类型是根据数据模型来划分的，每一个数据库产品都是
针对某种数据模型而设计的。基于关系数据模型的数据库，其数据结构是关系结
构，数据操作是建立在严格的数学理论之上的，这种数学理论是关系代数，经过
多年的发展，SQL 已经成为了表述关系操作的标准语言。
\section{分布式关系数据库}
\subsection{分布式存储}
分布式存储，相对于集中式存储，通常而言，是将数据存储在一个由网络连
通的多个结点构成的集群之上，向上层提供存储接口的一种存储系统。随着互联
网的普及以及各类在线应用的大量出现，许多互联网公司都面对海量数据存储的
压力。而分布式存储技术能提供对大规模数据的存储和访问，并且支持高可扩展
性，高并发，高性能。另外，很重要的一点，分布式技术能以非常廉价的成本提
供这样的服务，很多公司在起步阶段，着眼于业务的发展，而向数据存储厂商购
买数据存储服务，这些大型的高端服务器及其配套的软件和后续维护花费巨大，
在公司发展壮大之后多会转而自行部署分布式存储系统来解决数据存储的问题。
\subsection{分布式数据库的介绍}
分布式数据库是用计算机网络将物理上分散的多个数据库单元连接起来组成的一个
逻辑上统一的数据库。每个被连接起来的数据库单元称为站点或节点。分布式
数据库有一个统一的数据库管理系统来进行管理，称为分布式数据库管理系统。

分布式数据库的基本特点包括：物理分布性、逻辑整体性和站点自治性。从
这三个基本特点还可以导出的其它特点有：数据分布透明性、
按既定协议达成共识的机制、适当的数据冗余度和事务管理的分布性。

分布式数据库按照各站点中数据库管理系统的数据模型的异同分为异构型分布式
数据库和同构型分布式数据库，按照控制系统的类型分为全局控制集中性、全局控制分散型和全局控制可变型。

\noindent
优点：
\begin{enumerate}
\item 随时能针对各区域的用户做调整
\item 数据共用和分布式控制
\item 增加处理绩效，可作平行处理
\item 系统管理费用较低
\item 质量维持容易
\end{enumerate}
缺点：
\begin{enumerate}
\item 重复存储数据很花时间
\item 数据处理与管理上具复杂度
\item 数据的保密性与安全性受到威胁
\end{enumerate}
\section{分布式数据库相关技术}
\subsection{负载均衡技术}
面对大量用户访问、高并发请求，海量数据，可以使用高性能的服务器、大型数据
库，存储设备，高性能Web服务器，采用高效率的编程语言，当单
机容量达到极限时，我们需要考虑业务拆分和分布式部署
，来解决大型网站访问量大，并发量高，海量数据的问题。

从单机网站到分布式网站，很重要的区别是业务拆分和分布式部署，将应用拆分
后，部署到不同的机器上，实现大规模分布式系统。分布式和业务拆分解决了，
从集中到分布的问题，但是每个部署的独立业务还存在单点的问题和访问统一入口问题，
为解决单点故障，我们可以采取冗余的方式。将相同的应用部署到多台机器上
。解决访问统一入口问题，我们可以在集群前面增加负载均衡设备，实现流量分发。

负载均衡，意思是将负载进行平衡、分摊
到多个操作单元上进行执行。是解决高性能，单点故障,高可用
，扩展性的终极解决方案。

系统的扩展可分为纵向垂直扩展和横向水平扩展。纵向扩展，是从单机
的角度通过增加硬件处理能力，比如CPU处理能力，内存容量，磁盘等方面，实现
服务器处理能力的提升，不能满足大型分布式系统大流量，高并发，海
量数据的问题。因此需要采用横向扩展的方式，通过添加机器来满足大型网站服务的处理能力。
比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。

\noindent
负载均衡的作用：
\begin{enumerate}
	\item 解决并发压力，提高应用处理性能增加吞吐量，加强网络处理能力
	\item 提供故障转移，实现高可用
	\item 通过添加或减少服务器数量，提供网站伸缩性1扩展性
	\item 安全防护，负载均衡设备上做一些过滤，黑白名单等处理
\end{enumerate}

根据实现技术不同，可分为DNS负载均衡，HTTP负载均衡，IP负载均衡，链路层
负载均衡等。

\subsubsection{DNS负载均衡}
DNS负载均衡是最早的负载均衡技术，利用域名解析实现负载均衡，在DNS
服务器，配置多个A记录，这些A记录对应的服务器构成集群。
大型网站总是部分使用DNS解析，作为第一级负载均衡。

\noindent
优点：
\begin{enumerate}
	\item 使用简单：负载均衡工作，交给DNS服务器处理，省掉了负载均衡服务器维护的麻烦
	\item 提高性能：可以支持基于地址的域名解析，解析成距离用户最近
	的服务器地址，可以加快访问速度，改善性能；
\end{enumerate}

\noindent
缺点
\begin{enumerate}
	\item 可用性差：DNS解析是多级解析，新增修改DNS后，解析时间较长；解
	析过程中，用户访问网站将失败；
	\item 扩展性低：DNS负载均衡的控制权在域名商那里，无法对其做更多的改
	善和扩展；
	\item 维护性差：也不能反映服务器的当前运行状态；支持的算法少；不能区分
	服务器的差异,不能根据系统与服务的状态来判断负载.
\end{enumerate}

将DNS作为第一级负载均衡，A记录对应着内部负载均衡的IP地址，通过内部负载
均衡将请求分发到真实的Web服务器上。一般用于互联网公司，复杂的业务系统不合适使用。
\subsubsection{IP负载均衡}
IP负载均衡是
在网络层通过修改请求目标地址进行负载均衡。
用户请求数据包，到达负载均衡服务器后，负载均衡服务器在操作系统内
核进程获取网络数据包，根据负载均衡算法得到一台真实服务器地址，然
后将请求目的地址修改为，获得的真实ip地址，不需要经过用户进程处理。
真实服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器
，再将数据包源地址修改为自身的ip地址，发送给用户浏览器。
IP负载均衡，真实物理服务器返回给负载均衡服务器，存在两种方式：
负载均衡服务器在修改目的ip地址的同时修改源地址。将数据包源地址设
为自身盘，即源地址转换1snat。
将负载均衡服务器同时作为真实物理服务器集群的网关服务器。

优点：
	在内核进程完成数据分发，比在应用层分发性能更好。
缺点：
所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽。
\subsubsection{链路层负载均衡}
链路层负载均衡是在通信协议的数据链路层修改mac地址，进行负载均衡。
数据分发时，不修改ip地址，指修改目标mac地址，配置真实物理服务器集
群所有机器虚拟ip和负载均衡服务器ip地址一致，
达到不修改数据包的源地址和目标地址，进行数据分发的目的。
实际处理服务器ip和数据请求目的ip一致，不需要经过负载均衡服务器进行
地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡
服务器网卡带宽成为瓶颈。也称为直接路由模式1DR模式.

\noindent
优点：
\begin{enumerate}
	\item 性能好
	\item 配置复杂
\end{enumerate}

由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可
以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间
再一次负载均衡或群集起来以一个整体向外界提供服务即把这多个服务器群当做一个新
的服务器群，从而达到最佳的性能。将这种方式称之为混合型负载均衡。
此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情
况下。是目前大型互联网公司，普遍使用的方式。
\subsection{数据分片技术}
在分布式存储系统中，数据需要分散存储在多台设备上，数据分
片就是用来确定数据在多台存储设备上分布的技术。数据分片要达到三个目的：
\begin{enumerate}
	\item 分布均匀，即每台设备上的数据量要尽可能相近；
	\item 负载均衡，即每台设备上的请求量要尽可能相近；
	\item 扩缩容时产生的数据迁移尽可能少。
\end{enumerate}

数据分片一般都是使用Key或Key的哈希值来计算Key的分布，常见的几种数据分片的方法如下：
\begin{enumerate}
	\item 划分号段。这种一般适用于Key为整型的情况，每台设备上存放相同大小的号段区间，
	如把Key为[1, 10000]的数据放在第一台设备上，把Key为[10001, 20000]的数据放在第二
	台设备上，依次类推。这种方法实现很简单，扩容也比较方便，成倍增加设备即
	可，如原来有N台设备，再新增N台设备来扩容，把每台老设备上一半的数据迁移到新
	设备上，原来号段为[1, 10000]的设备，扩容后只保留号段[1, 5000]的
	数据，把号段为[5001, 10000]的数据迁移到一台新增的设备上。
	此方法的缺点是数据可能分布不均匀，如小号段数据量可能比大号段的数据量要大，
	同样的各个号段的热度也可能
	不一样，导致各个设备的负载不均衡；并且扩容也不够灵活，只能成倍地增加设备。
	
	\item 取模。这种方法先计算Key的哈希值，再对设备数量取模1整型的Key也可直接用Key
	取模1，假设有N台设备，编号为0~N-1，通过Hash1Key1N就可以确定数据所在的设备编号。
	这种方法实现也非常简单，数据分布和负载也会比较均匀，可以新增任何数量的设备来扩容
	。主要的问题是扩容的时候，会产生大量的数据迁移，比如从N台设备扩容
	到N+1台，绝大部分的数据都要在设备间进行迁移。
	检索表。在检索表中存储Key和设备的映射关系，通过查找检索表就可以确定数据分布，
	这里
	的检索表也可以比较灵活，可以对每个Key都存储映射关系，也可结合号段划分等方
	法来
	减小检索表的容量。这样可以做到数据均匀分布、负载均衡和扩缩容数据迁移量少
	。缺点是需要存储检索表的空间可能比较大，并且为了保证扩缩容引起的数据迁移量比
	较少，确定映射关系的算法也比较复杂。
	
	\item 一致性哈希。一致性哈希算法在1997年由麻省理工学院提出的
	一种分布式哈希实现算法，设计目标是为了解决因特网中的热点问题，
	一致性哈希的算法简单而巧妙，很容易做到数据均分布，
	其单调性也保证了扩缩容的数据迁移是比较少的。
	通过上面的对比，在这个系统选择一致性哈希的方法来进行数据分片。
\end{enumerate}
\subsection{数据库高可用技术}
高可用性指的是通过尽量缩短因日常维护操作和突发的系统崩溃所导致的停机时间，
以提高系统和应用的可用性。HA系统是目前企业防止核心计
算机系统因故障停机的最有效手段。

随着IT信息系统的不断发展，数据在企业的应用越来越广，如何提高IT系统的高可
用性成为建设稳健的计算机系统的首要任务之一。构成计算机网络系统的三大要素是
：网络系统，服务器系统，存储系统。网络系统包括防火墙，路由器等网络设备，
服务器系统主要指用户使用的各种服务器系统，存储系统，
则是用户最主要的数据存储放的地点。
因此IT系统的高可用建设应包括网络设备高可用性，服务器设备高可用性，及存
储设备的高可用性三个方面:

\noindent
\begin{enumerate}
	\item 网络高可用,由于网络存储的快速发展，网络冗余技术被不断提升，
	提高IT系统的高可用性的
	关键应用就是网络高可用性，网络高可用性与网络高可靠性是有区别的，
	网络高可用性是通过匹配冗余的网络设备实现网络设备的冗余，达到高可用的目的。
	比如冗余的交换机，冗余的路由器等
	\item 服务器高可用,
	服务器高可用主要使用的是服务器集群软件或高可用软件来实现。
	\item 存储高可用,
	使用软件或硬件技术实现存储的高度可用性。其主要技术指标是存储切换功能，
	数据复制功能，数据快照功能等。当一台存储出现故障时，
	另一台备用的存储可以快速切换，达一存储不停机的目的。
\end{enumerate}
\section{网络相关技术}
\subsection{TCP/IP协议}
TCPIP协议全称Transmission Control ProtocolInternet Protocol，中译名为传
输控制协议因特网互联协议，又名网络通讯协议，是Internet最基本的协议、
Internet国际互联网络的基础。

TCPIP是一个协议集合，寻址和路由选择以及传输控制是它的核心功能。
HTTP协议的基础是TCPIP协议，HTTP实现了服务器与客户端间的请求与响应，
TCPIP则实现了两端底层的数据传输‘36。37】。

网络层：网络层的协议包括IP协议、IGMP1因特网组管理协议1、ARP1地址解
析协议1、ICMP1因特网控制报文协议1、RARP1反向地址解析协议1。其中IP协议
向其它高层协议提供了基本的数据传输的功能，是无连接的、不可靠数据报协议。
传输层：TCP和UDP协议都使用IP网络层协议，是传输层的两个著名的协
议。为客户端和服务器上的应用程序提供端到端的通信。虽然TCP使用了不可靠
的IP网络层协议，但它却可以为主机问提供可靠的、面向连接的传输层数据通信
服务。与TCP不同的是，UDP为主机间提供无连接的、不可靠的传输层数据通
信。由于UDP协议开销很小，因此在特定领域也有着广泛的应用
应用层：用于处理应用程序的细节，这一层有许多协议，如Http、FTP、TELNET
世
i手。

连接建立、数据传送和连接终止是TCP连接的三个状态。TCP使用三次握手
1three．way handshake1协议来建立连接，终止一个连接要经过4次握手。在TCP
建立连接的过程中，将会初始化很多参数，例如对报文序号的初始化来保证连接
的强壮性和按序号传输。

111建立连接：在有些情况下会出现一对终端同时初始化一个他们之间的链
接的情况，但通常是由服务器端被动打开一个套接字1socket1监听来自客户端
的连接。客户端发送一个SYN报文段指明需要连接的服务器的端口，以及初始
顺序号来建立一个主动打开，作为三路握手的一部分。服务器发回包含服务器的
初始顺序号的SYN报文段1SY'N为11作为应答。同时，将确认号设置为客
户的ISN加1以对客户的SYN报文段进行确认1ACK也为11。服务器端
接收到来自客户端的SYN后一般会验证客户端的合法性，为每个合法的客户端发
送一个SYN／ACK。最后，客户端接收到服务器的响应后再发送一个ACK。这样
三路握手就完成了进入链接建立的状态。

121数据传输：为保证在TCP的数据传送状态下的可靠性和强壮性，主要
采取了一下机制，它们包括：对收到的TCP报文采用序号进行排序来检测重复数
据；采用校验和对报文段的错误进行检测；利用计时器对丢包或延时进行检测和
纠正。在的连接已经建立的状态下，两个主机的TCP层互相交换初始序号1ISN1。
初始序号除了能够对字节流中的数据进行标识以外，还可以用来对应用层的数据
字节进行记数。通常情况下

，序号和确认号存在于每个TCP报文段中。报文的发
送者将自己的字节编号称为序号，将接收者的字节编号称为确认号。为了保证报
文的可靠性，接收者在接收到一定数量的连续字节后才发送确认，这种被称为选
择确认的机制1SACK1是TCP的一种扩展。当数据以乱序到达接收者端时，如
果没有选择确认的机制，报文中的字节就不能按正确的顺序传递给应用层。
131链接终止：TCP用三个分节建立一个连接，终止一个连接则需要四个
分节，在标准的拆接过程中，链接的每一端都要提供一个FIN和ACK对。
\subsection{java流IO技术}
在Java的I／O类库中，“流”这一抽象的概念，通常用来表示接收数据的接
收端对象或是产生数据的数据源对象。“流”有效地封装了I／O中的实现细节，是
9
NIO高性能框架的研究与应用
Java平台I／O的基础。

就流的运动方向而言，流可以分为输入流1InputStream1和输出流
1OutputStream1，输入流代表从外设流入计算机的数据序列，而输出流则代表从
计算机流向外设的数据序列。在Java平台中，所有继承于InputStream的与输入有
关的类和所有继承于OutputStream与输出相关联的类，分别称为Java的I／O类库中
的输入和输出，是组成JavaI／O类库的两个主要组成部分。
从不同数据源产生输入的类用InputStream来表示。这些数据源包括：
111字节数组；
121String对象；
131文件；
141“管道”，工作模式类似于实际的管道，从一端输入，从另一端输出；
151序列；
161其他数据源，例如网络连接等。
abstract int read11是InputStream中的一个最主要的抽象方法方法该方法会返
回从输入源中读到的一个字节，当返回结果为一1时，表示已经读到了输入源的末
尾。设计具体的输入流类的时候，设计者需覆盖这个方法来提供详细的功能实现。
OutputStream决定数据输出的各种不同的目的地，这些目的地包括字节数组、
文件或管道等。与InputStream类似，OutputStream也提供了一个抽象方法abstract
int write1int b1交由设计者去覆盖实现，这个方法从要输出的数据中的一个字节写
到指定的目的地。

Javal.1版本对基本的I／O流类库进行了极大程度的修改。一开始看到
Reader1阅读器1和Writer1书写器1时，可能会误认为它们是用来替代InputStrearn
和OutputStream，但实际上不是这样的。InputStream和OutputStream仍然非常有
价值，特别是在面向字节形式的I／O中，Reader和Writer则为Unicode和面向字
符的I／O功能提供兼容。当需要把面

向字节形式的I／O中的类和向字符形式的I／O
中的类结合起来使用时，“适配器”1adapter1类可以起到中间桥梁的作用。在“适
配器”类中InputStreamReader能够将InputStream转换成Reader，而
OutputStreamWriter能够将OutputStream转换成Writer。Reader和Writer继承层
次结构的设计是为了满足国际化的需求。

Unicode是国际组织制定的可以容纳世
界上所有文字和符号的字符编码方案，由于在I／O流的继承层次结构中只能够支
持8位的字节流，当遇到16位的Unicode字符时处理起来很不方便。所以Javal.1
版本添加了Reader和Writer的继承层次结构为了来支持Unicode编码。

流I／O技术数据的输入输出时面向字节的，输入流每次一个一个字节地从数据
源读取数据，输出流也是每次向输出流一个一个字节的写入数据。相对于面向块
的数据读取而言，通过这种方式进行的数据读写速度很慢。同时，流I／O采用的是
阻塞的调用方式。在真正的写入或读取操作完成以前，工作线程都会被阻塞。这
意味着在复杂的网络环境中，由于网络连接繁忙而导致数据不能被流立即读取或
写入时，Java就会挂起这个工作线程，一直使其陷入等待的状态，直到流再次可
用为止。
\subsection{Socket编程技术}
Socket套接字是网络上服务器端与客户机端之间进行双向通信
的一方，可以
发送或接受连接请求，Socket将通信双方一端写入的信息发送至另外一端的
Socket中，利用Socket套接字可以方便地进行数据的传输。类似于文件传输的
输入输出流原理，Socket套接字通信可以通过读写数据实现对网络资源的使用
。Java中提供了两种套接字方式，分别为流式Socket和数据报式Socket，二
者的比较如表2．1：
表2．1流式与数据报式Socket类型比较
流式Socket通信服务的特点有：面向连接、可靠性高、有序、无差错、无重
复、可移植性好，支持TCP协议，可实现不同类型计算机之间的通信。

在客户机／服务器模式中，可以把Socket实例看作一个
特殊的实例对象，用
于描述IP地址和端12，是一个通信链的句柄。客户机端流套接字为Socket对象，
服务器端流套接字为ServerSocket对象，这两个对象中都封装了两个方法，分别
是输入流getlnputStream0和输出流getOutputStream0，是通信过程中实现Socket
通信连接的关键方法。Socket实现网络通信的流程如图2．2所示：
NIO高性能框架的研究与应用
客户端
调用9Dck烈O创建一
个会话
调用oonnectO与
咖端连接
调用recvO／send0进
行会话
aiseS：x：ketO关闭套
接字
服务器
调用9xket仓]建监听
调用bjndO为监听
9：，cket选择通信对象
调用list
调用ao：eptO接收连
接同时生成会话


三次握手，建立连接
请求连接
数据应答
调用recv11／sendO进
行会话
aosegx：ketO关闭套
接字
图2．2 Socket通1言机制
根据图2．3所示原理，PC机客户监控端与服务器端进行通信传输时，首先服
务器端创建Socket，调用bind11为监听Socket选择通信对象，同时调用listen11
和accept11等待客户端请求连接，客户端创建Socket并调用connect11尝试与服务
器端连接，然后开始调用read11和write11与服务器端数据进行数据传输，连接建
立完成。

服务器端程序编写：Java中使用专门建立Sock
et服
务器的类ServerSocket来
创建服务器对象，采用端口号作为传递参数
，且端口号是为了唯一标识每台PC机
的唯一服务的41。在服务器端建立Socke
t通信连接的步骤如下：
111首先在服务器端创建Socket并绑定到端口上；
ServerSocket server=new ServerSocket1int port1；
121不停监听客户机的连接请求，一旦监听到
客户机连接请求后，服务器调
用accept11函数并接受连接请求，完成S
ocket通信连接的建立；
Socket
s=SS．accept11；
131服务器端调用Socket类的输入输出函数以获取输入输出流，并利用输
入输出流进行数据的传输。
OutputStream OS=S．getOutputStream11；／／创建输出流
InputStream is=s．getlnputStreamO；／／仓JJ建输入流
OS．write1”Hello，welcome you!”．getBytes111；
byte[】aa=new byte[100]；／／建立字节数组
12
工程硕士学位论文
int len=is．read1a1；／／读取数据到数组中并返回实际读取的字节数
System．out．print1new String1a，0，1en11；
141关闭通信套接字。
客户机端和服务器端的类似：
111首先在客户机端创建Socket流套接字，并连接到服务器端；
Socket s=new
Socket1InetAddress．getByName1null1，port1；
121客户机端调用Socket对象的输入输出函数以获取输入输出流，并利用
输入输出流进行数据的传输。
OutputStream OS=s．getOutputStreamO；
InputStream
is 2s．getInputStreamO；
byte[】a=new byte[100]；int len=is．read1a1；／／从服务器端读取数据
System．out．print1new String1a，0，len11；
OS．write1”Hello，this
is
mengmeng"．getBytes01；
131关闭通信套接字。
\subsection{NIO技术}
在JDKI．4提出的新特性中，NIO技术是最大的亮点。与传统的流I／O技术相
比，NIO主要带来了两点改进：1．弥补了原来的I／O的不足，提供了面向块的、
非阻塞的I／O处理能力。2．使得Java应用程序能够更加充分地发挥操作系统的性
能，进行高性能的I／O操作。通道、缓冲区和选择器是NIO中三个最为关键的内
容

缓冲区是一个数据容器，缓冲区对象由一个用来存储数据的数组和一系列控
制数据读写的属性组成。在NIO技术中，所有数据的传输都是通过缓冲区来完成
的，这体现了与流I／O技术的一点主要的不同。在流I／O技术中，数据时直接读写
至1]Stream对象中的，而在NIO技术中，所有数据都是从缓冲区来读出和写入。所
有的缓冲区都具有四个属性来提供关于其所包含的数据元素的信息，它们分别是：
111容量1Capacity1：缓冲区能够容纳的数据元素的最大数量。这一容量
在缓冲区创建时被设定，并且永远不能被改变。
121上界1Limit1：缓冲区的第一个不能被读或写的元素。或者说，缓冲区
中现存元素的计数。
131位置1Position1：下一个要被读或写的元素的索引。位置会自动由相应
的get11和put11方法更新。
141标记1Mark1：一个备忘位置。调用mark11来设定mark=postion。调
用reset11设定position=mark。标记在设定前是未定义的1undefined1。
这四个属性之间总是遵循以下关系：0<=mark<=position<=limit<=
capacity。缓冲区结构图如图3．1所示：
17
通道1Channel1是java．nio的第二个主要创新。它们既不是一个扩展也不是
一项增强，而是全新、极好的Java I／O示例，提供与I／O服务的直接连接。Channel
用于在字节缓冲区和位于通道另一侧的实体1通常是一个文件或套接字1之间有
效地传输数据。通道与流相比不同之处在于通道是双向的，由于它是双向的，所
以通道比流能够更好地反映底层操作系统的真实情况。

选择器维护着注册过的通道的集合，并且这些注册关系中的任意一个都是封
装在SelectionKey对象中的。选择键封装了特定的通道与特定的选择器的注册关
系。选择键对象被SelectableChannel．register11返回并提供一个表示这种注册关系
的标记。选择键包含了两个比特集1以整数的形式进行编码1，指示了该注册关
系所关心的通道操作，以及通道已经准备好的操作。每一个Selector对象维护三
个键的集合：
111已注册的键的集合1Registered key set1：与选择器关联的已经注册的键的
集合。
121已选择的键的集合1Selected key set1：已注册的键的集合的子集。这个集
合的每个成员都是相关的通道被选择器1在前一个选择操作中1判断为已经准备
好的，并且包含于键的interest集合中的操作。
131已取消的键的集合1Cancelled key set1：已注册的键的集合的子集，这个
集合包含了cancel11方法被调用过的键1这个键已经被无效化1，但它们还没有被
注销。
选择器提供选择执行已经就绪的任务的能力，这使得多元I／O成为可能。就
绪选择和多元执行使得单线程能够有效率地同时管理多个I／O通道1channels1。
C／C++代码的工具箱中，许多年前就已经有select11和poll11这两个POSIX1可移
植性操作系统接口1系统调用可供使用了。许过操作系统也提供相似的功能，但
对Java程序员来说，就绪选择功能直到JDK 1．4才成为可行的方案。对于主要的
18
工程硕士学位论文
工作经验都是基于Java环境的开发的程序员来说，之前可能还没有碰到过这种
I／O模型。

数据打包和传输的方式是流I／O技术与NIO技术的一个重要的区别。流I／O
技术是面向字节的，而NIO技术通过块的方式来进行数据读写。在流I／O技术中，
数据的读写以一次一个字节地进行，这种处理方式I／O字节流必须顺序读取，处
理速度比较慢，经常用于间歇性输入。而在向块的I／O系统中，每一次操作都消
费一个数据块，比一个一个字节的读写数据要快得多。
NIO对非阻塞I／O操作的支持是其另外一个重要的特征。在NIO包中的多路
复用对象1Selector1提供选择执行已经就绪的任务的能力，这使得非阻塞I／O成
为可能。就绪选择使得单线程能够有效率地同时管理多个I／O通道1channels1。
C／C++代码的工具箱中，许多年前就已经有select11和poll11这两个POSIX1可移
植性操作系统接口1系统调用可供使用了。许过操作系统也提供相似的功能，但
对Java程序员来说，就绪选择功能直到JDK 1．4才成为可行的方案。
\subsection{线程池技术}
线程池（英语：thread pool）：一种线程使用模式。线程过多会带来
调度开销，进而影响缓存局部性和
整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避
免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内
核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内
核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适
，线程数过多会导致额外的线程切换开销。
任务调度以执行线程的常见方法是使用同步队列，称作任务队列。池中的线程等待队
列中的任务，并把执行完的任务放入完成队列中。
线程池模式一般分为两种：HS/HA半同步/半异步模式、L/F领导者与跟随者模式。

半同步/半异步模式又称为生产者消费者模式，是比较常见的实现方
式，比较简单。分为同步层、队列层、异步层三层。同步层的主线程处
理工作任务并存入工作队列，工作线程从工作队列取出任务进行处理，如果工作
队列为空，则取不到任务的工作线程进入挂起状态。由于线程间有数据通
信，因此不适于大数据量交换的场合。

领导者跟随者模式，在线程池中的线程可处在3种状态之一：
领导者leader、追随者follower或工作者processor。任何时刻线程池只有一个领导者线程。
事件到达时，领导者线程负责消息分离，并从处于追随者线程中选出一个来当继任领导者，
然后将自身设置为工作者状态去处置该事件。
处理完毕后工作者线程将自身的状态置为追随者。这一模式实现复杂，但避免了线程间交换任务数据，
提高了CPU cache相似性。
在ACE(Adaptive Communication Environment)中，提供了领导者跟随者模式实现。
\subsection{Reactor模式}
Reactor模型是一个事件触发模型，当有I／O读写操作准备就绪时，触发操作，
然后从线程池中选择线程进行处理。这种机制能够极大地减少线程浪费在等待数
据读写操作准备就绪上花费的时间，提高Java网络应用的并发性能。

分而治之是Reactor模型的模型思想，在Reactor模型中，客户端的请求事件
分为I／O事件和非I／O事件。这两种事件的区别在于I／O事件只有当I／O准备就绪
后才能进行，而非I／0事件是可以立即执行的，因此Reactor模型将这两种事件分
别进行处理。数据的读写属于I／O事件，编码、计算和解码属于非I／O事件。NIO
技术使得Java具备了非阻塞的读写能力，为这种Reactor模型的实现提供了很好
的支持。

reactor设计模式，是一种基于事件驱动的设计模式。Reactor框架是ACE各个框架中最基础的一个框架，
其他框架都或多或少地用到了Reactor框架。 

在事件驱动的应用中，将一个或多个客户的服务请求分离（demultiplex）和调度（dispatch）给应用程序。
在事件驱动的应用中，同步地、有序地处理同时接收的多个服务请求。 

reactor模式与外观模式有点像。不过，观察者模式与单个事件源关联，
而反应器模式则与多个事件源关联 。
当一个主体发生改变时，所有依属体都得到通知。
\noindent

\noindent
模型优点:
\begin{enumerate}
	\item 响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；
	\item 编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销； 
	\item 可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源； 
	\item 可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；
\end{enumerate}
\noindent

\noindent
模型缺点:
\begin{enumerate}
	\item 相比传统的简单模型，Reactor增加了一定的复杂性，
	因而有一定的门槛，并且不易于调试。
	\item Reactor模式需要底层的Synchronous Event Demultiplexer支持，
	比如Java中的Selector支持，操作系统的select系统调用支持
	，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。 
	\item Reactor模式在IO读写数据时还是在同一个线程中实现的，
	即使使用多个Reactor机制的情况下
	，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，
	会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，
	IO操作就会影响其他Client的相应时间，因而对这种操作，
	使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。 
\end{enumerate}
\section{Mysql通信协议的研究}
在MySQL数据库通信过程开始时，服务器会使用TCP监听一个本地socket
端口或本地socket链接。当一个客户端的连接请求到达，就会执行握手和权限验
证。如果验证成功，会话开始。客户端发送消息，服务器会以一个适合该发送命
令的数据类型的数据集或一条消息进行回复。当客户端发送完成后，会发送一个
特殊的命令，告诉服务器己发送，然后会话结束。通信的基本单位是应用程序包。
多个指令可以合成一个包；答复可以包含多个包。
\subsection{交互过程}
MySQL客户端与服务器的交互主要分为两个阶段：握手认证阶段和命令执
行阶段。

握手认证阶段为客户端与服务器建立连接后进行，开始连接的时候，
客服端发送握手初始化报文，然后客服端返回给服务器认证报文
，最后服务器返回认证结果。

客户端认证成功后，会进入命令执行阶段，交互过程如下：
客户端发送给服务器命令报文；
服务器返回客户端命令执行结果。
\subsection{协议基本类型}
mysql协议中主要有以下四种基本类型：
整型值，MySQL报文中整型值分别有l、2、3、4、8字节长度，使用小字节序传输；
以null结束的字符串；长度编码的字符串
字符串长度不固定，无null结束符；
长度编码的二进制数据，
数据长度不固定，长度值由数据前的1-9个字节决定，其中长度值所占的字
节数不定，字节数由第1个字节决定。
\subsection{mysql报文结构}
报文分为报文头和报文数据两部分，其中报文头占用固定的4个字节，
报文数据用于存放请求的内容及响应的数据，长度由报文头中的长度值决定。
\subsection{报文类型}
主要有下面几种报文类型：
\begin{enumerate}
	\item 登陆认证交互报文,建立TCP连接后，MySQL服务器向客户端
	\item 客服端命令请求报文,，对服务器的权能进行设置并等待客户端的验证包
	\item  服务器响应报文
\end{enumerate}
\subsection{Netty简介}
Netty是NIO客户端服务器框架，可以快速轻松地开发诸如协议服务器和客户端之类的网络应用程序。
 它大大简化了网络编程流程，如TCP和UDP套接字服务器。

“快速和容易”并不意味着由此产生的应用程序将遭受可维护性或性能问题的困扰。
 Netty已经通过执行许多协议（如FTP，SMTP，
HTTP以及各种基于二进制和基于文本的传统协议）获得的经验进行了精心设计。
 因此，Netty成功地找到了一种方法来实现轻松的开发，性能，稳定性和灵活性，而无需妥协。
\section{本章小结}
本章主要介绍了本论文相关的关键的理论和技术，包括分布式数据库方面的理论
，mysql协议的研究和学习，还有java相关的理论和技术。
