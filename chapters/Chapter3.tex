% !Mode:: "TeX:UTF-8"

\chapter{系统概述与分析}
JSQL作为一个分布式数据库，本章讨论了作为一个分布式系统，它的设计目标。
系统本身由很多模块组成。 
每个模块的实现都要用到不同的技术，本章还分析了jsql实现中每个模块所需要的详细技术，
对每个模块的功能进行分析。
\section{系统概述}
JSQL的目标是用java语言开发一个和mysql类似的数据库系统。
作为一个数据库系统，他的功能大概有如下：
\begin{enumerate}
	\item 数据定义：系统提供数据定义语言DDL，供用户定义数据库的三级模式结构、两级映像以及完整性约束和保密限制等约束。
	DDL主要用于建立、修改数据库的库结构。DDL所描述的库结构仅仅给出了数据库的框架，
	数据库的框架信息被存放在数据字典中。
	\item 数据操作：系统提供数据操作语言DML
	，供用户实现对数据的追加、删除、更新、查询等操作。
	\item 数据库的运行管理：数据库的运行管理功能是系统的运行控制、管理功能
	，包括多用户环境下的并发控制、安全性检查和存取限制控制、
	完整性检查和执行、运行日志的组织管理、事
	务的管理和自动恢复，即保证事务的原子性。这些功能保证了数据库系统的正常运行。
	\item 数据组织、存储与管理：系统要分类组织、存储和管理各种数据，
	包括数据字典、用户数据、存取路径等，需确定以何种文件结
	构和存取方式在存储级上组织这些数据，如何实现数据之间的联系。
	数据组织和存储的基本目标是提高存储空间利用率，选择合适的存取方法提高存取效率。
	\item   数据库的保护：数据库中的数据是信息社会的战略资源，所以数据的保护至关重要。系统
	对数据库的保护通过4个方面来实现：数据库的恢复、数据库的并发控制、数据库的完整性控制
	、数据库安全性控制。系统的其他保护功能还有系统缓冲区的管理以及数据存储的某些自适应调节机制等。
	\item  数据库的维护：这一部分包括数据库的数据载入、转换、转储、数据库的重组合重构以及性能监控等功能，这些功能分别由各个使用程序来完成。
	\item 通信：系统具有与操作系统的联机处理、分时系统及远程作业输入的相关接口，负责处理数据的
	传送。对网络环境下的数据库系统，还应该包括系统与网络中其他软件系统的通信功能以及数据库之间的互操作功能。
\end{enumerate}
\section{网络实现分析}
所有的服务软件都需要实现网络模块，这样才能连接客服端的请求。
JSQL用java语言开发，主要用到的是java的网络开发模块。
\subsection{JAVA网络技术}
IO的方式通常分为几种，同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO\citeup{thesis20}。
\subsubsection{BIO}
在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，
需要先在服务端启动一个ServerSocket，
然后在客户端启动Socket来对服务端进行通信，
默认情况下服务端需要对每个请求建立一堆线程等待请求，
而客户端发送请求后，先咨询服务端是否有线程相应
，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。
\subsubsection{NIO}
NIO本身是基于事件驱动思想来完成的
，其主要想解决的是BIO的大并发问题：
 在使用同步I/O的网络应用中，如果要同时处理多个客
 户端请求，或是在客户端要同时和多个服务器进行通讯
 ，就必须使用多线程来处理。也就是说，将每一个客户端
 请求分配给一个线程来单独处理。这样做虽然可以达到我们
 的要求，但同时又会带来另外一个问题。由于每创建一个线程
 ，就要为这个线程分配一定的内存空间（也叫工作存储器），而
 且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过
 多，服务端程序可能会因为不堪重负而
 拒绝客户端的请求，甚至服务器可能会因此而瘫痪。
 
NIO基于Reactor，当socket有流可读或可写入socket时，
操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。
 也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，
 而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。

BIO与NIO一个比较重要的不同
，是我们使用BIO的时候往往会引入多线程，
每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。

NIO的最重要的地方是当一个连接创建后，
不需要对应一个线程，这个连接会被注册到多路复用器上面，
所以所有的连接只需要一个线程就可以搞定，当这个线程中的多
路复用器进行轮询的时候，发现连接上有请求的话，才开启一个
线程进行处理，也就是一个请求一个线程模式。

在NIO的处理方式中，当一个请求来的话，
开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，
其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。

HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，
这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中
可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传
送给后端资源池或者队列里面就返回，并且在全局的地方保持住这
个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接
受其他的请求，而后端的应用的处理只需要执行队列里
面的就可以了，这样请求处理和后端应用是异步的.
当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。

\subsubsection{AIO}
与NIO不同，当进行读写操作时，
只须直接调用API的read或write方法即可。
这两种方法均为异步的，对于读操作而言，当有流可读取时，
操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；
对于写操作而言，当操作系统将write方法传递的流写入完毕时，
操作系统主动通知应用程序。 
 即可以理解为，read/write方法都是异步的
 ，完成后会主动调用回调函数。  在JDK1.7中，这部分内容被称作NIO.2，
 主要在Java.nio.channels包下增加了下面四个异步通道：
\begin{enumerate}
	\item AsynchronousSocketChannel
 \item  AsynchronousServerSocketChannel
\item AsynchronousFileChannel
\item AsynchronousDatagramChannel
\end{enumerate}
其中的read/write方法，会返回一个带回调函数的对象，
当执行完读取/写入操作后，直接调用回调函数。

Java对BIO、NIO、AIO的支持：
\begin{enumerate}
	\item Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端
	就需要启动一个线程进行处理，如果这个连接不
	做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
\item Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，
即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到
连接有I/O请求时才启动一个线程进行处理。
\item Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式
为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，
\end{enumerate}
BIO、NIO、AIO适用场景分析:
\begin{enumerate}
	\item BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，
	并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
\item NIO方式适用于连接数目多且连接比较短（轻操作）的架构，
比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
\item AIO方式使用于连接数目多且连接比较长（重操作）的架构，
比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。
\end{enumerate}
另外，I/O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。

在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。
在比较这两个模式之前，我们首先的搞明白几个概念，什么是阻塞和非阻塞
，什么是同步和异步,同步和异步是针对应用程序和内核的交互而言的，
同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪
，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作
已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问
数据的时候，根据IO操作的就绪状态来采取的不同方式，
说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。
\subsubsection{Netty}
\pic[htbp]{Netty}{}{netty}
Netty的主要目的是建立基于NIO（或可能的NIO.2）的高性能协议服务器，分离和松散耦合网络和业务逻辑组件。
它可能会实现一个广为人知的协议，如HTTP或您自己的特定协议。
Netty的线程模型如如\ref{netty}所示。


Netty是一个非阻塞框架。与阻塞IO相比，这导致高吞吐量。
Netty使用事件驱动的应用程序范例，因此数据处理的流水线是一系列事件处理程序。
事件和处理程序可以与入站和出站数据流相关联。入站事件可以如下：

\begin{enumerate}
	\item 通道激活和停用
\item 阅读操作事件
\item 异常事件
\item 用户事件
\end{enumerate}
出站事件更简单，通常与打开/关闭连接和写入/刷新数据有关。

Netty应用程序由几个网络和应用程序逻辑事件及其处理程序组成
。通道事件处理程序的基础接口是ChannelHandler及其祖先ChannelOutboundHandler和ChannelInboundHandler。

Netty提供了一个巨大的ChannelHandler实现层次结构
。值得注意的只是空的实现的适配器
，例如ChannelInboundHandlerAdapter和ChannelOutboundHandlerAdapter。
当我们需要处理所有事件的一个子集时，我们可以扩展这些适配器。

此外，还有许多具体协议的实现方式，
如HTTP，例如HttpRequestDecoder，HttpResponseEncoder，HttpObjectAggregator。在Netty的Javadoc中熟悉他们是件好事。


当我们使用网络协议时，我们需要执行数据序列化和反序列化。为了这个目的，
Netty的介绍的特殊扩展ChannelInboundHandler为解码器，
其能够进入的数据进行解码。大多数解码器的基类是ByteToMessageDecoder。
对于编码输出数据，Netty具有被称为编码器的ChannelOutboundHandler的扩展。
MessageToByteEncoder是大多数编码器实现的基础。我们可以使用编码器和解码器将消息从字节序列转换为Java对象，反之亦然。

因为Netty的这些特效，利用它可以实现一个高性能的网络应用程序，所以本系统的网络模块也是用的Netty来
实现的，它直接高并发的客服端访问。
\section{通信协议分析}
每个服务器和客服端通信都要实现自己的通信协议，考虑到mysql使用的广泛性。jsql采用mysql的通信协议。这样就不用自己开发协议了。

Mysql协议的交互过程如图\ref{mysqljh}所示。
\pic[htbp]{MYSQL协议交互过程}{}{mysqljh}
\section{SQL实现分析}
结构化查询语言是一种特殊目的编程语言，
用于数据库中的标准数据查询语言，IBM公司最早使用在其
开发的数据库系统中。1986年10月，美国国家标准协会对SQL进行规范后，以此作为
关系式数据库管理系统的标准语言（ANSI X3. 135-1986），
1987年得到国际标准组织的支持下成为国际标准。
不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。
所以，实际上不同数据库系统之间的SQL不能完全相互通用 ,
 甚至不同版本间也可能无法互通。

SQL是高级的非过程化编程语言，它允许用户在高层数据结构上工作。
它不要求用户指定对数据的存放方法，也不需要用户了解其具体的数据存放方式。
而它的界面，能使具有底层结构完全不同的数据库系统和不同数据库之间，
使用相同的SQL作为数据的输入与管理。它以记录项目〔records〕的合集（set）〔项集，record set〕作为操纵对象
，所有SQL语句接受项集作为输入，回提交的项集作为输出，这种项集特性允许一条SQL语句的输出作
为另一条SQL语句的输入，所以SQL语句可以嵌套
，这使它拥有极大的灵活性和强大的功能。在多数情况下，
在其他编程语言中需要用一大段程序才可实践的一个单独事件
，而其在SQL上只需要一个语句就可以被表达出来。
这也意味着用SQL可以写出非常复杂的语句，
在不特别考虑性能下。
SQL同时也是数据库文件格式的扩展名。
SQL包含四个部分：

\begin{enumerate}
	\item 数据定义语言
\item 数据操纵语言
\item 数据控制语言
\item 事务控制语言
\end{enumerate}

mysql支持的sql语句和标准的sql语句不全一样，它支持下面这几种语句类型：

\begin{enumerate}
	\item 数据定义语句     
\item 数据操作语句     
\item 交易和锁定声明     
\item 复制语句     
\item 准备的SQL语句语法     
\item 复合语句语法     
\item 数据库管理语句     
\item 效用声明  
\end{enumerate}   
其中每种语句类型又分为很多种sql语句，所以mysql支持的sql语句非常的多，因为本系统选择了兼容mysql的协议，所以我们
也要解析这些不同的sql语句，解析sql语句是一种很麻烦的事情，所以我
用了一个成熟的开源的sql解析框架Druid。

Parser 由两部分组成，词法分析和语法分析。
当拿到一条形如 select id, name from user 的 SQL 语句后
，首先需要解析出每个独立的单词，select，id，name，from，user。
这一部分，称为词法分析，也叫作Lexer。
通过词法分析后，便要进行语法分析了。
经常能听到很多人在调侃自己英文水平很一般时会说：
26个字母我都知道，但是一组合在一起我就不知道是什么意思了
。这说明他掌握了词法分析的技能，却没有掌握语法分析的技能。
那么对于 SQL 解析器来说呢，它不仅需要知道每个单词
，而且要知道这些单词组合在一起后，表达了什么含义。
语法分析的职责就是明确一个语句的语义，表达的是什意思。
自然语言和形式语言的一个重要区别是，自然语言的一个语句，
可能有多重含义，而形式语言的一个语句，只能有一个语义;
形式语言的语法是人为规定的，有了一定的语法规则，
语法解析器就能根据语法规则，解析出一个语句的一个唯一含义。

AST 是 Parser 的产物，语句经过词法分析，语法分析后，它
的结构需要以一种计算机能读懂的方式表达出来，最常用的就是抽象语法树。
树的概念很接近于一个语句结构的表示，一个语句，我们经常会
对它这样看待：它由哪些部分组成？其中一个组成部分又有哪些部分组成？
例如一条 select 语句，它由 select 列表、where 子句、排序字段、
分组字段等组成，而 select 列表则由一个或多个 select 项组成，where 子句又由一个或者多个 where条件组成。
在我们人类的思维中，这种组成结构就是一个总分的逻辑结构，
用树来表达，最合适不过。并且对于计算机来说
，它显然比人类更擅长处理“树”。

AST 仅仅是语义的表示，但如何对这个语义进行表达，
便需要去访问这棵 AST，看它到底表达什么含义。通常遍历语法树
，使用 VISITOR 模式去遍历，从根节点开始遍历，一直到最后一个叶子节点，
在遍历的过程中，便不断地收集信息到一个上下文中，整个遍历过程
完成后，对这棵树所表达的语法含义，已经被保存到上下文了
。有时候一次遍历还不够，需要二次遍历。遍历的方式，
广度优先的遍历方式是最常见的。

利用Druid可以简化对sql语句的解析过程，同时也让系统更改高效。
\section{存储引擎分析}
存储引擎是存储系统的发动机，直接决定了存储系统能够提供的性能和功能。存储
系统的基本功能包括：增、删、读、改，其中，读取操作又分为随机读取和顺序扫描。
每种存储引擎底层都基于一种数据结构。比如常用的哈希表结构和B+树结构。
本系统用的是一种叫HashTree的数据结构，它的结果如图\ref{hashtree}所示。
\pic[htbp]{HashTree结构图}{}{hashtree}

哈希树(HashTree)算法就是要提供一种在理论上和实际应用中均能有效地处理冲突的方法。
一般的哈希(Hash)算法都是O(1)的，
\subsection{哈希树的理论基础}
哈希树的理论基础是质数分辨定理，
简单地说就是：n个不同的质数
可以“分辨”的连续整数的个数和他们的乘积相等。
“分辨”就是指这些连续的整数不可能有完全相同的余数序列。

例如：
从2起的连续质数，连续$ 10 $个质数就可以分辨大约$ M(10) =2*3*5*7*11*13*17*19*23*29= 6464693230  $个数，
已经超过计算机中常用整数的表达范围。连续100个质数就可以分辨大约$ M(100) = 4.711930 *10^{219} $。
而按照目前的CPU水平，$ 100 $次取余的整数除法操作几乎不算什么难事。
在实际应用中，整体的操作速度往往取决于节点将关键字装载内存的次数和时间。
一般来说，装载的时间是由关键字的大小和硬件来决定的；
在相同类型关键字和相同硬件条件下，
实际的整体操作时间就主要取决于装载的次数。
他们之间是一个成正比的关系。

\subsubsection{优点}
结构简单，从哈希树的结构来说，非常的简单。
每层节点的子节点个数为连续的质数。子节点可
以随时创建。因此哈希树的结构是动态
的，也不像某些哈希算法那样需要长时间的初始化过程
。哈希树也没有必要为不存在的关键字提前分配空间。
需要注意的是哈希树是一个单向增加的结构，即
随着所需要存储的数据量增加而增大。即使数据量减
少到原来的数量，但是哈希树的总节点数不会减少。这样做的目的是为了避免结构的调整带来的额外消耗。

查找迅速，
从算法过程我们可以看出，对于整数，哈希树层级最多能增加到1$ 0 $
。因此最多只需要十次取余和比较操作，就可以知道这个对象是否存在
。这个在算法逻辑上决定了哈希树的优越性。
一般的树状结构，往往随着层次和层次中节点数的增加而导致更
多的比较操作。操作次数可以说无法准确确定上限。而哈希树的查找
次数和元素个数没有关系。如果元素的连续关键字总个数在计算机的整数
所能表达的最大范围内，那么比较次数就
最多不会超过$ 10 $次，通常低于这个数值。 

结构不变，
从删除算法中可以看出，哈希树在删除的时候，并不做任何结构调整。这
个也是它的一个非常好的优点。常规树结构在增加元素和删除元素
的时候都要做一定的结构调整，否则他们将可能退化为链表结构，
而导致查找效率的降低。哈希树采取的是一种“见缝插针”的算
法，从来不用担心退化的问题，也不必为优化结构
而采取额外的操作，因此大大节约了操作时
间。

\subsubsection{缺点}
非排序性，
哈希树不支持排序，没有顺序特性
。如果在此基础上不做任何改进的话并试图通过遍历来实现排序，那么操作效率将远远低于其他类型的数据结构。

关于超长字符串的问题，
如果是超长字符串的关键字，该如何处理？若把它们按26进制每一位都转换为数字，则得到的结果太大。
我们可以用MD5等消息压缩算法来生成定长的整数。
MD5算法具有以下特点：
\begin{enumerate}
	\item 压缩性：任意长度的数据，算出的MD5值长度都是固定的。
\item 容易计算：从原数据计算出MD5值很容易。
\item 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
\item 弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
\item 强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。
\end{enumerate}
对于超长字符串，我们可以用MD5算法生成一个128bit的整数，
然后用RadixTree(翻看前面博客)来存储这个大整数，
或者使用哈希树来存储，对于这样的大整数，
我们不能简单地使用计算机的整数来做除法，
而是使用程序模拟人工的除法方式来做除法并获得余数。
内存映射文件(Memory-mapped file)，
或称“文件映射”、“映射文件”，
是一段虚内存逐字节对应于一个文件或类文件的资源，使得应用程序处理映射部分如同访问主内存。

主要用处是增加I/O性能，特别是用于大文件。对于小文件，
内存映射文件会导致碎片空间浪费，
因为内存映射总是要对其页边界，这起码是4 KiB。
因而一个5 KiB文件将会映射占用8 KiB内存，
浪费了3 KiB内存。访问内存映射文件比
直接文件读写要快几个数量级。
内存映射文件可以只加载一部分内容到用
户的逻辑内存空间。这对非常大的文件特别有用。
使用内存映射文件可以避免颠簸：把相当大的文
件直接加载到内存时，由于可用内存不足，使得
一边读取文件内存，同时把部分已经加载的文件从内存写入硬盘虚存文件中。
内存映射文件由操作系统的内存管理程序负责，
因此绕过了硬盘虚存的分页文件（page file）。

在各种数据结构（线性表、树等）中，记录在结构中的相对位置是随机的。因此在机构中查找记录的时需要进行一
系列和关键字的比较。这一类的查找方法建立在“比较”的基础上。查找的效率依赖于查找过程中所进行的
比较次数。
之前我们介绍的各种基于比较的树查找算法，这些查找算法的效率都将随着数据记录数的增长而下降。仅仅是有的
比较慢（时间复杂度为O(n)），有的比较快（时间复杂度是O(logn)）而已。这些查找算法的平均查找长度是在一
种比较理想的情况下获得的。在实际应用当中，对数据结构中数据的频繁增加和删除将不断地改变着数据的结构。
这些操作将可能导致某些数据结构退化为链表结构，那么其性能必然将下降。为了避免出现这种情况而采取
的调整措施，又不可避免的增加了程序的复杂程度以及操作的额外时间。

理想的情况是希望不经过任何比较，一次存取便能得到所查的记录，那就必须在记的存储位置和它的关键字之间建
立一个确定的对应关系f，使每个关键字和一个唯一的存储位置相对应。
因而在查找时，只要根据这个对应关系f找到给定值K的像f(K)。由此，不
需要进行比较便可直接取得所查记录。在此，我们称这个对应关系为哈
希（Hash）函数，按这个思想建立的表为哈希表。

在哈希表中对于不同的关键字可能得到同一哈希地址，这种现象称做冲突。在一般情况下，冲突只能尽可能地减少
，而不能完全避免。因为哈希函数是从关键字集合到地址集合的映像。通常关键字
的集合比较大，它的元素包括所有可能的关键字，而地址集合的元素仅为哈希表中
的地址值。在一般情况下，哈希函数是一个压缩映像函数，这就不可避免的要产生冲突。

这样，使用MD5和选用更大的质数相结合的办法。这样就可以使得通过层次比
较少的哈希树来获得对关键字区间的完整覆盖。这样就减少了比较操作的次数，并提高整体的工作效率。
\section{分布式实现分析}
在计算中，Hazelcast是基于Java的开源 内存 数据网格。
它也是开发产品的公司的名称。Hazelcast公司由风险投资资助。
在一个Hazelcast网格中，数据被一个均匀的节点之间分配计算机集群，
从而允许水平缩放的处理和可用存储。备份也分布在节点之
间，以防止任何单个节点的故障。Hazelcast通过内存中
访问经常使用的数据和可弹性扩展的数据网格，提供中
央，可预测的应用程序扩展。这些技术减少了对数据库的查询负载，并提高了速度
Hazelcast平台可以管理许多不同类型应用程序的内存
。它提供了一个开放二进制客户端协议，
以支持任何二进制编程语言的API。
Hazelcast和开源社区成员已经为包含Java，Scala，.NET Framework，C ++，Python，Node.js和Clojure的
编程语言创建了客户端API 。Java和Scala可以用于客户端和嵌入式成员。

利用Hazelcast可以轻松开发出各种的分布式应用程序，而且部署非常简单，
只需要嵌入它的二进制包就可以直接使用，避免再部署另外的系统来实现分布式，
所以本系统选择了它来实现分布式的功能。
\section{监控模块分析}
本系统实现最简单的监控模块，一个监控模块首先要存储
所有的日志数据，而且这个数据不能随意的更改，所以我改了Elasticsearch的源代码，
让它来存储所有的sql更新记录，然后用可视化的框架来显示出结果。

Elasticsearch是基于Lucene的搜索引擎。
它提供了一个分布式，多租户的全文搜索引擎，
具有HTTP Web界面和无模式的JSON文档。Elasticsearch在开发的Java，
并发布为开放源代码下的条款Apache许可证。
官方客户可以使用Java，.NET（C＃），PHP，Python，Groovy等许多语言。
Elasticsearch是Apache Solr最受欢迎的企业搜索引擎，也是基于Lucene的。
Elasticsearch与名为Logstash的数据收集和日志解析引擎以及名为Kibana的
分析和可视化平台一起开发。这三款产品设计用作集成解决方案，
被称为“弹性栈”（以前称为“ELK堆栈”）。
\section{本章小结}
JSQL作为一个分布式数据库，本章讨论了作为一个分布式系统，它的设计目标。
系统本身由很多模块组成。 
每个模块的实现都要用到不同的技术，本章还分析了jsql实现中每个模块所需要的详细技术，
对每种技术进行了分析。