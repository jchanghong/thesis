% !Mode:: "TeX:UTF-8"

\chapter{系统分析}
本章主要写了又那些数据库，每种数据库的特点。
\section{需求分析}
\subsection{功能需求}
数据库，简单来说就是电脑文件中存储的信息，用户可以对文件中的数据运行
新增、截取、更新、删除等操作。
数据库指的是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、
与应用程序彼此独立的数据集合。

数据库管理系统（英语：Database Management System，简称DBMS）
是为管理数据库而设计的电脑软件系统，
一般具有存储、截取、安全保障、备份等基础功能。
数据库管理系统可以依据它所支持的数据库模型来作分类，最重要的是关系型数据库。

结构化查询语言（英语：Structured Query Language，缩写：SQL）
，是一种特殊目的之编程语言
，用于数据库中的标准数据查询语言。不过各
种通行的数据库系统在其实践过程中都对SQ
L规范作了某些编改和扩充。所以，
实际上不同数据库系统之间的SQL不能完全相互通用。
本论文实现的Jsql是采用的mysql的SQL方言。

所以简单的说，要实现jsql数据库，对于用户来说，就是要实现mysql支持的sql语句。

mysql支持的sql语句有下面几种类型：
\begin{enumerate}
	\item 数据定义语句
	\item 数据操作语句
	\item 交易和锁定声明
	\item 复制语句
	\item 准备的SQL语句
	\item 复合语句
	\item 数据库管理语句
	\item 工具语句
\end{enumerate}

当然，mysql本身是一个单机版数据库，所以有的sql语句类型不适合jsql这样的分布式数据库。
比如，因为单机mysql无法满足应用的要求，所以有了复制的功能。
但是，jsql本身就是一个分布式数据库，所以也就不需要再实现这样的复制功能了。
\subsection{性能需求}
Jsql系统是一个基于java语言实现的分布式数据库。它采用了和mysql一样的sql语法作为查询
语言。

一方面，当查询只涉及到单结点上的数据库时，JSQL 的表现应当与传统数据
库相当，即，当 JSQL 执行子计划中有对单表的增加，删除，修改，和查找操作时，
这些操作的性能表现应当与 Mysql 相似。

另一方面，当查询涉及到跨结点的关系时。由于结点之间消息传递，就时延
这一性能而言，在执行相同操作时，必然是分布式关系数据库不如传统数据库。
但是，当面对的数据量足够大时，网络开销在总时间中的占比可能会较小，使得
分布式数据库能有接近传统数据库的表现。
\section{集群实现分析}
集群（cluster）技术是一种较新的技术，通过集群技术，
可以在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益，
其任务调度则是集群系统中的核心技术。
集群是一组相互独立的、通过高速网络互联的计算机，
它们构成了一个组，并以单一系统的模式加以管理。
一个客户与集群相互作用时，集群像是一个独立的服务器。
集群配置是用于提高可用性和可缩放性。

要实现数据库集群是一个非常困难的工作，一般人很难没有差错的完成这个功能。
所以市面上出现了各种各样的功能库以减少开发者的工作。
为了减少工作量，增加稳定性。论文决定采用hazelcast这个分布式集群库。

Hazelcast 没有任何中心节点（文中的节点可以理解为运行在任意服务器的独立jvm，下同），
或者说Hazelcast 不需要特别指定一个中心节点。在运行
的过程中，它自己选定集群中的某个节点作为中心点来管理所有的节点。

 Hazelcast 的数据是分布式存储的。他会将数据尽量存储在需要使
 用该项数据的节点上，以实现数据去中心化的目的。在传统的
 数据存储模型中（MySql、MongDB、Redis 等等）数据都是
 独立于应用单独存放，当需要提升数据库的性能时，需要不
 断加固单个数据库应用的性能。即使是现在大量的数据库支
 持集群模式或读写分离，但是基本思路都是某几个库支
 持写入数据，其他的库不断的拷贝更新数据副本。
 这样做的坏处一是会产生大量脏读的问题，二
 是消耗大量的资源来传递数据——从数据源频
 繁读写
 数据会耗费额外资源，当数据量增长
 或创建的主从服务越来越多时，这个消耗呈指数级增长。

使用 Hazelcast 可以有效的解决数据中心化问题。他
将数据分散的存储在每个节点中，节点越多越分散。每个
节点都有各自的应用服务，而Hazelcast集群会根据每
个应用的数据使用情况分散存储这些数据，在应用过程
中数据会尽量“靠近”应用存放。这些在集群中的数据共
享整个集群的存储空间和计算资源。

  集群中的节点是无中心化的，每个节点都有可能随时退
  出或随时进入。因此，在集群中存储的数据都会有一个
  备份（可以配置备份的个数，也可以关闭数据备份）。这样的
  方式有点类似于 hadoop，某项数据存放在一个
  节点时，在其他节点必定有至少一个备份存在。当某个节点退出时，节点上存放的数据会由备份数据替
  代，而集群会重新创建新的备份数据。
  
    所有的 Hazelcast 功能只需引用一个jar包，除此之外，他不依
    赖任何第三方包。因此可以非常便捷高效的将其嵌入到各种应用服务器中，
    而不必担心带来额外的问题（jar包冲突、类型冲突等等）。
    他仅仅提供一系列分布式功能，而不需要绑定任何框架来使用，因此适用于任何场景。

利用hazelcast，我们开发了无中心节点的分布式集群数据库。
\section{审计实现分析}
数据库是任何商业和公共安全中最具有战略性的资产，通常都保存着重要的
商业伙伴和客户信息，这些信息需要被保护起来，以防止竞争者和其他非法者获
酬。互联网的急速发展使得企业数据库信息的价值及可访问性得到了提升，
同时，也致使数据库信息资产面临严峻的挑战，概括起来主要表现在以下三个层
面：

1．管理风险：主要表现为人员的职责、流程有待完善，内部员工的日常操作
有待规范，第三方维护人员的操作监控失效等等，离职员工的后门，致使安全事
件发生时，无法追溯并定位真实的操作者。其中典型的例子，曾为西藏移动进行
设备安装工作的原深圳某高科技公司的工程师利用它为西藏移动做技术时使用
的密码(此密码自工程师离开后一直没有更改)，轻松进入了西藏移动的服务器，
再跳转到北京移动的服务器，从而通过修改系统的数据库轻松获得了14000个充
值卡密码并获得380万元的利益。

2．技术风险：Oracle，SQL Server是一个庞大而复杂的系统，安全漏洞如溢
出， 注入层出不穷，每一次的CPUIl4J(Critical Patch Update)都疲丁奔命， 而
企业和政府处于稳定性考虑，往往对补丁的跟进非常延后，更何况通过应用层的
注入攻击使得数据库处于一个无辜受害的状态。

3．审计层面：现有的依赖于数据库日志文件的审计方法，存在诸多的弊端，
比如：数据库审计功能的开启会影响数据库本身的性能、数据库日志文件本身存
在被篡改的风险，难于体现审计信息的有效性和公正性。此外，对于海量数据的
挖掘和迅速定位也是任何审计系统必须面对和解决的一个核心问题之一【1引。
伴随着数据库信息价值以及可访问性提升，使得数据库面对来自内部和外部
的安全风险大大增加，如违规越权操作、恶意入侵导致机密信息窃取泄漏，但事
后却无法有效追溯和审计。

数据库审计的目标概括来说主要是三个方面：一是让管理者实时全面了解数
据库实际发生的操作情况；二是在可疑行为发生时可以自动启动预先设置的告
警流程，尽可能防范数据库风险的发生；三是一旦发生非法操作，触发事先设
置好的防御策略，实行阻断，实现主动防御。因此，如何采取一种可信赖的综
合途径，确保数据库活动记录的百分之百的被捕获是极为重要的，
任何一种遗漏关键活
动的行为，都会导致数据库安全上的错误判断，并且干扰数据库在运行时的性
能。

本论文的安全审计子系统，能够根监视安全数据库系统中的相关活动，
并执行相应动作。通过考．
察、跟踪审计信息，审计员可以查看特定用户在过去一段时间内的数据访问行
为，特定数据对象曾被访问的情况，以及曾试图对该数据库系统进行的非法操‘
作等。审计员可以监督包括管理员在内的所有用户的操作。此外，还能通过对
审计记录的分析，对系统的运行情况进行检查，排除可能存在的安全漏洞。

为实现这些审计目标，首先要对数据库的各种操作记录继续记录，防止记录被
其他人更改，还要让安全管理员方便的查询审计记录。根据审计记录做个预警
也是一种很重要的功能
\section{编程模型分析}
数据库的实现需要网络和磁盘的io，
如何高效的利用操作系统和各种技术实现高性能的io模型是每个网络应该程序，
包括数据库系统的重要目标。本小节介绍各种io模型。

说到IO模型，都会牵扯到同步、异步、阻塞、非阻塞这几个词。从词的表面上看
，很多人都觉得很容易理解。但是细细一想，却总会发现有点摸不着头脑。
自己也曾被这几个词弄的迷迷糊糊的，每次看相关资料弄明白了，
然后很快又给搞混了。经历过这么几次之后，
发现这东西必须得有所总结提炼才不至于再次混为一谈
。尤其是最近看到好几篇讲这个的文章，很多都有谬误，
很容易把本来就搞不清楚的人弄的更加迷糊。

最适合IO模型的例子应该是咱们平常生活中的去餐馆吃饭这个场景
，下文就结合这个来讲解一下经典的几个IO模型。在此之前，先需要说明以下几点：
IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。
阻塞和非阻塞，是函数/方法的实现方式，即在数据就绪之前是立刻返回还是
等待，即发起IO请求是否会被阻塞。
以文件IO为例,一个IO读过程是文件数据从磁盘到内核缓冲区再到用户内存
的过程。同步与异步的区别主要在于数据从内核缓冲区到用户内存这个过程
需不需要用户进程等待，即实际的IO读写是否阻塞请
求进程。(网络IO把磁盘换做网卡即可)
\subsection{同步阻塞}
	 去餐馆吃饭，
	点一个自己最爱吃的盖浇饭，然后在原地等着一直到盖浇饭做
	好，自己端到餐桌就餐。这就是典型的同步阻塞。当厨师给你做饭
	的时候，你需要一直在那里等着。
	
	网络编程中，读取客户端的数据需要调用recvfrom。在默认情况下，这个
	调用会一直阻塞直到数据接收完毕，就是一个同步阻塞的IO方式。这也是
	最简单的IO模型，在通常fd较少、就绪很快的情况下使用是没有问题的。
	
 \subsection{同步非阻塞}
	接着上面的例子，你每次点完饭就在那里等着，突然有一天你发现自
	己真傻。于是，你点完之后，就回桌子那里坐着，然后估计差不
	多了，就问老板
	饭好了没，如果好了就去端，没好的话就等一会再去问，依次循环
	直到饭做好。这就是同步非阻塞。
	
	这种方式在编程中对socket设置ONONBLOCK即可。但此方式仅
	仅针对网络IO有效，对磁盘IO并没有作用。因为本地文件IO就没
	有被认为是阻塞，我们所说的网络IO的阻塞是因为网路IO有
	无限阻塞的可
	能，而本地文件除非是被锁住，否则是不可能无限阻塞的，因此只有
	锁这种情况下，ONONBLOCK才会有作用。而且，磁盘IO时
	要么数据在内核
	缓冲区中直接可以返回，要么需要调用物理设备去读取
	，这时候进程的其他工作都需要等待。因此，后续的IO复用和信号驱
	动IO对文件IO也是没有意义的。
	
	此外，需要说明的一点是nginx和node中对于本地文件的IO
	是用线程的方式模拟非阻塞的效果的，而对于静态文件的io
	，使用zero copy(例如sendfile)的效率是非常高的。
\subsection{IO复用}

接着上面的列子，你点一份饭然后循环的去问好没好显然有点得
不偿失，还不如就等在那里直到准备好，但是当你点了好几样饭菜的
时候，你每次都去问一下所有饭菜的状态(未做好/已做好)肯定比你每次
阻塞在那里等着好多了。当然，你问的时候是需要阻塞的，一直到有准备
好的饭菜或者你等的不耐烦(超时)。这就引出了IO复用，也叫多路IO就绪通知。
这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件
就绪了，就通知进程。使得一个进程能在
一连串的事件上等待。
IO复用的实现方式目前主要有select、poll和epoll。

select和poll的原理基本相同：
注册待侦听的fd(这里的fd创建时最好使用非阻塞)；
每次调用都去检查这些fd的状态，当有一个或者多个fd就绪的时候返回；
返回结果中包括已就绪和未就绪的fd。
相比select，poll解决了单个进程能够打开的文件描述符数量有限制这个问题
：select受限于FDSIZE的限制，如果修改则需要修改这个宏重新编译内核；而po
ll通过一个pollfd数组向内核传递需要关注的事件，避开了文件描述符数量限制。
此外，select和poll共同具有的一个很大的缺点就是包含大量fd的数组被整体
复制于用户态和内核态地址空间之间
，开销会随着fd数量增多而线性增大。

select和poll就类似于上面说的就餐方式。但当你每次都去询问时，老板会把所有
你点的饭菜都轮询一遍再告诉你情况，当大量饭菜很长时间都不能准备好的情况下是
很低效的。于是，老板有些不耐烦了，就让厨师每做好一个菜就通知他。这样每次
你再去问的时候，他会直接把已经准备好的菜告诉你，你再去端。
这就是事件驱动IO就绪通知的方式epoll。
epoll的出现，解决了select、poll的缺点：
基于事件驱动的方式，避免了每次都要把所有fd都扫描一遍；
epollwait只返回就绪的fd；
epoll使用nmap内存映射技术避免了内存复制的开销。
epoll的fd数量上限是操作系统的最大文件句柄数目,这个数目一般和内存
有关，通常远大于1024。
目前，epoll是Linux2.6下最高效的IO复用方式，也是Nginx、Node的I
O实现方式。而在freeBSD下，kqueue是另一种类似于epoll的IO复用方式。
此外，对于IO复用还有一个水平触发和边缘触发的概念：
水平触发，就是当就绪的fd未被用户进程处理后，下一次查询依旧
会返回，这是select和poll的触发方式；
边缘触发，就是无论就绪的fd是否被处理，下一次不再返回。
理论上性能更高，但是实现相当复杂，并且任何意外的丢失事件都会
造成请求处理错误。epoll默认使用水平触发，通过相应选项可以使用边缘触发。
\subsection{信号驱动}
上文的就餐方式还是需要你每次都去问一下饭菜状况。于是
，你再次不耐烦了，就跟老板说，哪个饭菜好了就通知我一声吧。然
后就自己坐在桌子那里干自己的事情。更甚者，你可以把手机号留给老板，自己出门，等饭菜好了直接发条短信给你。这就类似信号驱动的IO模型。
流程如下：
开启套接字信号驱动IO功能；
系统调用sigaction执行信号处理函数（非阻塞，立刻返回）；
数据就绪，生成sigio信号，通过信号回调通知应用来读取数据。
此种io方式存在的一个很大的问题：Linux中信号队列是
有限制的，如果超过这个数字问题就无法读取数据。

\subsection{异步非阻塞}
之前的就餐方式，到最后总是需要你自己去把饭菜端到餐桌。这下你也不
耐烦了，于是就告诉老板，能不能饭好了直接端到你的面前或者送到
你的家里(外卖)。这就是异步非阻塞IO了。
对比信号驱动IO，异步IO的主要区别在于：信号驱动由内核告诉我们
何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内
核通知IO操作何时已经完成(数据已经在用户空间中)。

异步IO又叫做事件驱动IO，在Unix中，POSIX1003.1标准为异步方式访
问文件定义了一套库函数，定义了AIO的一系列接口。使用aioread或
者aiowrite发起异步IO操作，使用aioerror检查正在运行的IO操作的状态。但
是其实现没有通过内核而是使用了多线程阻塞。此外，还有Linux自己
实现的Native AIO，依赖两个函数：iosubmit和iogetevents，虽然io是非阻塞的
，但仍需要主动去获取读写的状态。
需要特别注意的是：AIO是I/O处理模式，是一种接口标准，各家操
作系统可以实现也可以不实现。目前Linux中AIO的内核实现只对文件IO有
效，如果要实现真正的AIO，需要用户自己来实现。

\subsection{网络编程模型}
上文讲述了UNIX环境的五种IO模型。基于这五种模型
，在Java中，随
着NIO和NIO2.0(AIO)的引入，一般具有以下几种网络编程模型：
BIO，
NIO，
AIO。

BIO是一个典型的网络编程模型，是通常我们实现一个服务端
程序的过程，步骤如下：
主线程accept请求阻塞；
请求到达，创建新的线程来处理这个套接字，完成对客户端的响应。
主线程继续accept下一个请求
这种模型有一个很大的问题是：当客户端连接增多时，服务端创建的线
程也会暴涨，系统性能会急剧下降。因此，在此模型的基础上，类似于 tomcat
的bio connector，采用的是线程池来避免对于每一个客户端都创建一
个线程。有些地方把这种方式叫做伪异步IO(把请求抛到线程池中异步等待处理)。

JDK1.4开始引入了NIO类库，这
里的NIO指的是Non-blcok IO
，主要是使用Selector多路复用器来实现。
Selector在Linux等主流操作系统上是通过epoll实现的。
NIO的实现流程，类似于select：
创建ServerSocketChannel监听客户端连接并绑定监听端口；
设置为非阻塞模式；
创建Reactor线程，创建多路复用器(Selector)并启动线程；
将ServerSocketChannel注册到Reactor线程的Select
or上；监听accept事件；
Selector在线程run方法中无线循环轮询准备就绪的Key；
Selector监听到新的客户端接入，处理新的请求，完成tc
p三次握手，建立物理连接；
将新的客户端连接注册到Selector上，监听读操作；
读取客户端发送的网络消息。
客户端发送的数据就绪则读取客户端请求，进行处理。
相比BIO，NIO的编程非常复杂。

JDK1.7引入NIO2.0，提供了异步文件通道
和异步套接字通道的实现
。其底层在windows上是通过IOCP，在Linux上
是通过epoll来实现的
(LinuxAsynchronousChannelProvider.
java,UnixAsynchronousServerSocketChannelImpl.java)。

创建AsynchronousServerSocketChannel
，绑定监听端口
调用AsynchronousServerSocketChannel的accpet方法，
传入自己实现的CompletionHandler。包括上一步，都是非阻塞的
连接传入，回调CompletionHandler的completed方法，在里面
，调用AsynchronousSocketChannel的read方法，
传入负责处理数据的CompletionHandler。
数据就绪，触发负责处理数据的CompletionHandler
的completed方法。继续做下一步处理即可。
写入操作类似，也需要传入CompletionHandler。
其编程模型相比NIO有了不少的简化。
\section{本章小结}
存储部分的数据库主要分为两大类：关系型数据库与 NoSQL 数据
库。