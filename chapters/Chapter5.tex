% !Mode:: "TeX:UTF-8"

\chapter{系统实现}
在对系统进行详细设计以后，就是编码实现阶段。
本章按照前一章的设计，给出每个功能模块的具体实现。详细分析关键功能实现流程图，
也包括对关键代码的分析。
\section{代码规范和总体结构}
本数据库系统采用和JAVA语言类似的
Kotlin语言开发。JAVA中的代码以包为组织单位，
这样组织代码的好处是逻辑结构分明。表\ref{codepdf/allpackage}描述了本系统所有的包
和每个包的详细功能。
其中每个包实现具体的功能，这样分配代码在大型工程实践中很常见。
除了逻辑清晰，方便管理以外，同时也方便团队协作。
\pictable[htbp]{本系统所有包和各个包的作用}{}{codepdf/allpackage}
在所有包里面，config包没有实现具体的功能，这个包主要包括了系统常用的配置信息。
图\ref{codepdf/config}给出了config包下面每个类的具体作用，这个包主要是让用户可以配置
数据库的各个方面，比如配置数据库的端口号，配置最大的连接数等等。
\pictable[htbp]{config包下面每个类的作用}{}{codepdf/config}
在本章的后面会给出其他其他功能模块的详细实现。
\section{客服端功能实现}
客服端主要实现负载均衡功能，利于JDBC连接后端的分布式数据库，
利用网络连接到分布式管理节点得到分布式数据库节点
的IP地址。在分布式管理节点为客服端返回正确数据库地址以后，
客服端就可以通过JDBC连接数据库节点。
客服端连接功能流程图如图\ref{pic5/kefuduan}所示。
\pic[htbp]{客服端连接功能流程图}{}{pic5/kefuduan}

首先，判断客服端有没有已经登录的会话，如果已经有已经登录的会话，那么就可以直接和对应的分布式数据库节点连接。
发送数据库命令并且得到返回结果。当客服端没有连接会话的时候，客服端就首先连接分布式管理节点，分布式管理为客服端返回合适的
数据节点地址，然后客服端利用这个地址再连接数据库服务器。
通过这样一个步骤，分布式管理节点能利用合适的负载均衡算法为客服端选择合适的数据库节点，有利于服务器资源的均衡利用。
\section{分布式管理节点实现}
管理节点存储数据库集群的元数据，实现分布式负载均衡功能。同时也为管理员提供管理和监控功能。
本节主要对分布式管理节点的负载均衡的实现进行说明。
\section{负载均衡功能实现}
负载均衡有两方面的含义: 首先, 将大量的并发访问或数据流量分
担到多台节点设备上分别处理, 减少用户等待响应的时间; 其次, 单个重
负载的运算分担到多台节点设备上做并行处理, 每个节点设备处理结束
后, 将结果汇总, 返回给用户, 系统处理能力得到大幅度提高。负载均衡
能够均衡所有的服务器和应用之间的通信负载, 根据实时响应时间进行
判断, 将任务交由负载最轻的服务器来处理, 以实现真正的智能通信管
理和最佳的服务性能。


负载均衡包括静态负载平衡和动态负载平衡。只是利用系统负载的
平均信息, 而忽视系统当前的负载状况的方法被称为静态负载均衡; 根
据系统当前的负载状况来调整任务划分的方法被称为动态负载均衡。目
前, 静态负载均衡已越来越不能满足需要, 动态负载均衡技术有取而代
之的趋势。动态均衡技术又可以分为集中式方法和分布式方法，在集中方法中，单个节点
负责管理内部整个节点的负载状态信息，有单点故障的危险；
分布式方法中，每个节点，
通过收集独立构建自己的负载状态信息，然后把负载信息分享给其他节点，同时能在集群中保存元数据，负者分布式管理功能的节点挂掉的时候，可以通过选择一个新的管理节点。
本论文实现了一种新的分布式负载均衡算法，分布式管理节点就是这样的管理节点。

在集群启动的时候，初始化管理节点，其流程如图\ref{pic5/fuzai1}所示。
\pic[htbp]{分布式管理节点初始化流程}{}{pic5/fuzai1}

第一步，分布式数据库集群中的节点根据一定的方法选出一个节点作用分布式管理节点。管理节点除了能存储数据，响应用户的数据操作请求以外，还能作为分布式管理节点。分布式管理节点的作用就是为数据库客户端选择正确的后端数据库服务器，作为负载均衡功能的总代理。

第二步，分布式数据库集群中
每个服务器节点根据公式\ref{fuzai2}得到自己的权重值P，然后发送到分布式管理节点存储。其中
$ L_c $为服务器节点CPU的个数， $ L_r $为当前服务器总内存。
\begin{equation}
P=L_c * L_r \label{fuzai2}
\end{equation}

第三步，分布式数据库节点每过1秒就根据公式\ref{fuzai3}得到自己当前的负载S，同时发送到分布式管理节点。其中$ C $为当前CPU使用率， $ R $为当前服务器内存剩余量，单位为兆。
\begin{equation}
S =
\begin{cases}
1 & \text{if } C >0.9 \: \text{or} \: R<300,\\
0 & \text{if } \text{other}.
\end{cases}   \label{fuzai3}
\end{equation}

第四步，分布式管理节点根据根据每个服务器节点的权重排序，然后使其排列成一个圆形。最后一个服务器下一个服务器为第一个服务器，保存在数据库的元数据中。这样分布式负载均衡就初始化完成了。

在集群初始化完成以后，每当客户端发出连接请求，分布式管理节点就会为客户端选择正确的服务器地址，其流程如图\ref{pic5/fuzai2}所示。
\pic[htbp]{负载均衡流程图}{}{pic5/fuzai2}
当分布式管理节点收到客户端请求以后，遍历数据库的元数据库，依次检查其中的每个服务器节点，如果没有更多的服务器就返回错误信息；如果有的话，检查当前遍历节点的负载S。
如果$ S=0 $就返回当前服务器的地址，算法结束，下一次遍历的时候从下一个服务器节点开始检查；如果$ S=1 $就跳过这个节点，再检查下一个节点，如此循环，直到算法正确结束或者返回给客户端错误消息。
\section{多版本MVCC算法实现}
2.7.3.1 Megastore 中的 MVCC
Megastore 利用了 Big Table 中数据的多版本特性实现分布式的更新事务。每个事务更新的都是
不同版本（timestamp）的 Big Table 数据，在读取数据时利用 timestamp 过滤，从而不会读到正在进
行的尚未生效的事务数据。其原理与本节中介绍完全一致，不再赘述。
2.7.3.2 Doris*中的 MVCC
在 Doris*系统中，数据按批量进行更新，每个批量的数据都可以认为是一个事务，必须同时原
子性的生效。为此，Doris*将每条数据附带了一个导入的版本号，在读取数据时根据元数据中已生
效的版本号与数据上的导入版本号做过滤，从而不读取正在更新的尚未生效的数据，实现了分布式
事务更新。其详细流量与本节中介绍的一致。
\section{数据库系统实现}
数据库系统功能在是分布式数据库节点中最重要的
功能模块，提供数据的更删改查的功能。
在源代码实现里面，
SQL包下面的类主要是作为数据库系统管理类，
让用户启动数据库服务器或者关闭数据库服务器。
表\ref{codepdf/sql}描述了SQL包下每个类的作用。
\pictable[htbp]{SQL包的每个类的作用}{}{codepdf/sql}
其中SpringMain类是数据库系统功能的入口，这个类主要调用其他模块，完成数据库系统的启动。
ShutdownMain类用来关闭数据库系统。
按照客服端请求信息的处理流程，
数据库功能模块主要包括网络模块，SQL解析模块和存储引擎模块，
下面分别描述每个模块具体的实现。
\subsection{网络模块}
在网络模块，处理网络套接字的连接和网络字节的处理。
在分布式数据库节点接收到客服端的套接字连接请求以后，
网络模块服务器端套接字接收请求，完成三次握手建立连接以后。交个Netty来处理。
网络字节处理模块主要是用了Netty来实现的，所有和网络字节处理有关的代码都在netty包下面。表\ref{codepdf/netty}描述了每个类的
功能。
\pictable[htbp]{网络模块中各个类的作用}{}{codepdf/netty}
在接收到客服端套接字连接以后，客服端信息会依次经过下面四个类的处理：
\begin{enumerate}
	\item ByteToMysqlDecoder
	\item ByteToMysqlPacket
	\item MysqlPacketHander
	\item NettyServer
\end{enumerate}
具体处理流程如图\ref{pic5/wangluo}所示。
\pic[htbp]{网络模块功能图}{}{pic5/wangluo}
网络模块收到客服端的套接字连接以后需要包网络字节包装成Mysql的消息包格式，如果错误就说明客服端不是我们的客服端或者客服端发送了其他的错误。当截取到消息包格式以后，还需要解析成我们的数据结构，如果解析成功就包数据结构发送到解析模块，如果解析错误，就断开连接。

除了实现网络模块以外，我们还要实现通信协议，系统
采用了和mysql一样的通信协议，在mysql包下面实现了mysql的通信协议。
表\ref{codepdf/mysql}给出了实现通信协议所用到的所有的类。
\pictable[htbp]{通信协议实现所用到的类}{}{codepdf/mysql}

网络服务器接受到客服端的连接以后，就要解析mysql的通信协议，
把每一个消息包封装到具体的对象里面，表\ref{codepdf/mysqlmysql}描述了所有的mysql通信协议的封装对象。
\pictable[htbp]{mysql所有协议包的封装对象}{}{codepdf/mysqlmysql}
mysql协议里面有很多的包，每个协议包都
需要一个类来实现，图\ref{pic5/woshou}是握手包的类图，
\pic[htbp]{握手包实现类图}{}{pic5/woshou}
其他包的实现大体相同，所以在这里不再重复说明。

解析到协议包以后我们就要对协议包进行处理，
协议包的主要有两个阶段，一个是认证阶段，一个是命令阶段，认证阶段就是
接受客服端的请求，然后检查用户的认证信息，比如用户名和密码，
图\ref{pic5/renzheng}显示了认证流程过程。
\pic[htbp]{认证流程图}{}{pic5/renzheng}
如果认证成功以后，就建立连接会话，然后客服端就可以进行向服务器发送命令请求向分布式数据库节点处理数据。
如果失败失败就返回给客服端失败原因。
认证成功以后就是命令阶段，服务器接受客服端的命令，然后处理，
图\ref{pic5/mingling}显示了命令处理流程。
\pic[htbp]{命令处理流程图}{}{pic5/mingling}
在接收到客服端的命令请求以后，网络模块就会调用下面模块的功能接口来对这个命令进行处理。
如果命令处理过程中没有发生异常，那么就把命令处理结果发送给客服端，如果命令处理工程中发送了异常，就返回失败原因。
\subsection{SQL解析模块}
经过网络模块的处理，我们建立了客服端的连接会话，接下来我们就要对客服端发送过来的命令进行判断，如果是SQL命令，就要对这个命令进行解析，进行词法分析，语法分析和语意检查。
在代码实现中，sql包下面的类主要完成对客服端连接和会话的封装和管理，表\ref{codepdf/jsqlsql}显示了sql包下面每个类的具体作用。
\pictable[htbp]{SQL前端连接模块相关的类}{}{codepdf/jsqlsql}
在sql解析功能模块里面系统用到了druid开源框架，用来解析sql，解析sql以后就要做具体的数据处理，
图\ref{pic5/sqlchuli}显示了SQL模块的处理流程图。
\pic[htbp]{SQL处理流程图}{}{pic5/sqlchuli}
在sql解析流程中，如果遇到Druid框架不支持的语句，我们就要自己对这个语句进行解析。再这个工程中。任何一个步骤发送错误就返回错误信息给客服端。不然就进行发送给下一个功能模块进行具体的数据操作。
mysql当中的sql语句有很多种，每一种语句都要做不同的处理，
\ref{codepdf/sqljiexi}描述了sql模块下实现的各种类型的
语句。
\pictable[htbp]{SQL模块下实现的各种类型的语句}{}{codepdf/sqljiexi}

每一种类型语句下面又回有很多种具体语句的实现，表\ref{codepdf/sqlddm}给出了数据
操纵类型语句实现的所有相关的类和响应的功能。
其他类型的语句也需要进行相同的处理，这里就不再进行详细表述。
\pictable[htbp]{数据操纵数据实现所相关的类}{}{codepdf/sqlddm}
\subsection{存储引擎模块}
存储引擎有关的功能主要在storage包下面实现，表\ref{codepdf/storage}给出了
storage包下面各种文件的功能。
\pictable[htbp]{storage包下面各种文件的作用}{}{codepdf/storage}
其中DB类作为底层存储引擎的接口，他的功能接口如表\ref{codepdf/db}所示。
\pictable[htbp]{数据库存储引擎的函数接口}{}{codepdf/db}
和表有关的功能接口如表\ref{codepdf/table}所示。
\pictable[htbp]{数据库引擎和表有关功能的接口}{}{codepdf/table}

存储引擎利用非关系型数据存储，为上面模块提供操作接口。其中有关数据库操作的类接口如图\ref{pic5/db}b所示，有关表操作的类接口如图\ref{pic5/table}所示。
类的实现主要是封装了OrientDB存储引擎的功能，为上一次提供关系操作的接口。在关系数据库中，操作接口就是SQL语言。JSQL因为选择了兼容Mysql协议，所以实现了大部分的Mysql语句功能。这样上层功能模块就可以当做Mysql一样的使用本数据库引擎。
\pic[htbp]{数据库操作接口类图}{}{pic5/db}
\pic[htbp]{表操作接口类图}{}{pic5/table}
\section{集群架构的实现}
集群功能主要是利用了开源的hazelcast框架来实现，
其中的功能全在hazelcast包下面实现，表\ref{codepdf/hazelcast}给出了
该包下面每个类的具体的作用。
\pictable[htbp]{集群模块下面各个类的作用}{}{codepdf/hazelcast}
其中最关键的代码如下。

\input{codetex/MyHazelcast.kt.tex}

\section{数据审计模块的实现}
JSQL除了结合关系数据库和非关系型数据库以外，还从数据库的底层考虑数据的安全问题，对数据审计功能进行了简单的实现，在代码实现中，
审计模块有关的功能全部在audit包下面实现，
表\ref{codepdf/audit}给出了audit包下面
每个类的具体的作用。
\pictable[htbp]{audit包下面每个类的作用}{}{codepdf/audit}
其中LoginLog和SQLlog类主要封装了两种日志类型，一种是客服端的登录记录日志，一种是客服端的命令执行日志。
通过封装这两种日志记录，很容易的就可以实现审计数据的收集和发送功能。
图\ref{pic5/shenji}显示了审计功能演示图。
\pic[htbp]{审计功能演示图}{}{pic5/shenji}
审计功能主要包括审计数据库，审计管理器和审计可视化功能模块，下面分别对每个模块进行说明
\begin{enumerate}[fullwidth,itemindent=2em,listparindent=2em]
	\item 审计数据库:
	审计数据库用Elasticsearch来实现，
	作为审计数据库，不能让用户随意的更改，
	所以本系统更改了它的源代码，使得它只能增加数据和查找数据
	不能更改和删除数据。其中主要存储的对象如图\ref{codepdf/audit}所示。
	\item 审计管理器:
	审计管理功能全部在audit下面实现，主要是存储本地的日志文件，
	然后发布到审计数据库。
	提供给前端可视化的接口。
	\item 审计可视化模块的实现:
	审计可视化模块的实现用到了grafana，
	主要用来监控ELK中的数据。管理员通过连接分布式管理节点可以对审计数据进行查询。从而对数据的更改情况进行掌控。
\end{enumerate}
\section{本章小结}
本文前面一章设计了本系统的架构图和各个模块的详细功能，本章给出
每个功能模块的具体实现。。