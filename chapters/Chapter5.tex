% !Mode:: "TeX:UTF-8"

\chapter{系统实现}
在对系统进行总体设计和详细设计以后，就是编码实现阶段。
本章按照前一章的功能模块设计，给出其中关键功能模块的具体实现。详细分析关键功能实现流程图，
对系统所用关键算法进行说明。
\section{代码规范和总体结构}
本数据库系统采用和JAVA语言类似的
Kotlin语言开发。JAVA中的代码以包为组织单位，
这样组织代码的好处是逻辑结构分明。表\ref{codepdf/allpackage}描述了本系统所有的包
和每个包的详细功能。
其中每个包实现具体的功能，这样分配代码在大型工程实践中很常见。
除了逻辑清晰，方便管理以外，同时也方便团队协作。
\pictable[htbp]{本系统所有包和各个包的作用}{}{codepdf/allpackage}
在所有包里面，config包没有实现具体的功能，这个包主要包括了系统常用的配置信息。

图\ref{codepdf/config}给出了config包下面每个类的具体作用，这个包主要是让用户可以配置
数据库的各个方面，比如配置数据库的端口号，配置最大的连接数等等。为了方便对软件系统的代码进行管理，本论文所述系统全部实现代码都放在github上面进行保存和管理。
\pictable[htbp]{config包下面每个类的作用}{}{codepdf/config}
在本章的后面会给出其他关键功能模块的详细实现。
\section{客户端功能关键技术实现}
在分布式数据库系统中，客户端模块的功能主要是连接分布式数据库节点服务器，在分布式管理节点的配合下，为用户选择合适的后端分布式数据库集群节点，实现服务器资源的均衡利用。
客户端在得到分布式数据库节点网络地址以后，就可以通过JDBC连接后端的分布式数据库节点。

利用网络连接到分布式管理节点得到分布式数据库节点
的IP地址。在分布式管理节点为客户端返回正确数据库服务器地址以后，
客户端就可以通过JDBC连接数据库服务器节点。
客户端连接功能流程图如图\ref{pic5/kefuduan}所示。
\pic[htbp]{客户端连接功能流程图}{}{pic5/kefuduan}

首先，判断客户端有没有已经登录的会话，如果已经有已经登录的会话，那么就可以直接和对应的分布式数据库节点连接。
发送数据库命令并且得到返回结果。当客户端没有连接会话的时候，客户端就首先连接分布式管理节点，分布式管理为客户端返回合适的
数据节点地址，然后客户端利用这个地址再连接数据库服务器。
通过这样一个步骤，分布式管理节点能利用合适的负载均衡算法为客户端选择合适的数据库节点，有利于服务器集群资源的均衡分配。
\section{分布式负载均衡算法实现}
在JSQL分布式数据库中，管理节点存储数据库集群的元数据，实现分布式负载均衡功能。同时也为管理员提供管理和监控功能。
本节主要对分布式管理节点的负载均衡功能的实现进行说明。

负载均衡就是根据当前分布式系统节点的性能和负载状态信息，为客户端选择合适的分布式节点。
达到均衡分配系统资源的目的。有利于系统资源的高效使用，提高系统的整体效率。
同时也提高了系统的性能，为客户端选择的合适节点，也能节约网络负载资源。


根据算法考虑当前服务器的负载状态信息与否，负载均衡算法可以分为动态算法和静态算法
目
前, 静态负载均衡因为负载均衡效果已越来越不能满足需要, 动态负载均衡技术有取而代
之的趋势。

动态均衡技术又可以分为集中式算法和分布式算法，在集中式算法中，单个节点
负责管理内部整个节点的负载状态信息，有单点故障的危险；
分布式算法中，每个节点通过收集自己的负载状态信息，然后把负载信息分享给其他节点，同时能在集群中保存元数据，负责分布式管理功能的节点挂掉的时候，可以通过选举算法选择一个新的管理节点，避免单点故障。

本论文实现了一种新的分布式负载均衡算法，其采用分布式集群来管理动态负载均衡信息，避免单点故障，负载效果良好。分布式负载均衡算法包括初始化和选举两个阶段。
\subsection{管理节点初始化实现}
在集群启动的时候，初始化管理节点，其算法流程如图\ref{pic5/fuzai1}所示。
\pic[htbp]{分布式管理节点初始化流程}{}{pic5/fuzai1}

第一步，分布式数据库集群中的节点根据一定的方法选出一个节点作用分布式管理节点。管理节点除了能存储数据，响应用户的数据操作请求以外，还能作为分布式管理节点。分布式管理节点的作用就是为数据库客户端选择正确的后端数据库服务器，作为负载均衡功能的总代理。

第二步，分布式数据库集群中
每个服务器节点根据公式\ref{fuzai2}得到自己的权重值P，然后发送到分布式管理节点存储。其中
$ L_c $为服务器节点CPU的个数， $ L_r $为当前服务器总内存。
\begin{equation}
P=L_c * L_r \label{fuzai2}
\end{equation}

第三步，分布式数据库节点每过1秒就根据公式\ref{fuzai3}得到自己当前的负载S，同时发送到分布式管理节点。其中$ C $为当前CPU使用率， $ R $为当前服务器内存剩余量，单位为兆。
\begin{equation}
S =
\begin{cases}
1 & \text{if } C >0.9 \: \text{or} \: R<300,\\
0 & \text{if } \text{other}.
\end{cases}   \label{fuzai3}
\end{equation}

第四步，分布式管理节点根据根据每个服务器节点的权重排序，然后使其排列成一个圆形，最后一个服务器的下一个服务器为第一个服务器，保存在数据库的元数据中。这样分布式负载均衡就初始化完成了。
\subsection{选举算法实现}
在管理节点初始化完成以后，分布式集群中的服务器通过心跳定时向管理节点发送自身服务器信负载信息。在正确维护集群元数据以后，就可以利用选举算法为客户端选择合适的分布式数据库节点。
每当客户端发出连接请求，分布式管理节点就会为客户端选择正确的服务器地址，其流程如图\ref{pic5/fuzai2}所示。
\pic[htbp]{负载均衡选举流程图}{}{pic5/fuzai2}

当分布式管理节点收到客户端请求以后，遍历数据库的元数据库，依次检查其中的每个服务器节点，如果没有更多的服务器就返回错误信息；如果有的话，检查当前遍历节点的负载S。
如果$ S=0 $就返回当前服务器的地址，算法结束，下一次遍历的时候从下一个服务器节点开始检查；如果$ S=1 $就跳过这个节点，再检查下一个节点，如此循环，直到算法正确结束或者返回给客户端错误消息。

按照上面的动态负载均衡算法来实现管理节点负载均衡功能，有如下好处：
\begin{enumerate}
	\item 管理节点其实和分布式数据库节点一样，都是分布式集群中的一台服务器，只是选择出来一个作为管理节点。分布式负载信息保存在所有服务器里面，所以当当前管理节点下线的时候，可以通过hazelcast选举出下一个管理节点，避免单点故障。
	\item 考虑到每个服务器的处理器和内存信息，根据每个服务器的能力进行排序。
	每次选举的时候都是从元数据数组的下一个节点选择，这样就可以避免一个大服务器全部处理客户端请求的情况。当处理器和内存到达一定的时候，就暂时放弃当前服务器。这样可以获取更好的均衡效果。
\end{enumerate}
\section{多主分布式架构关键技术实现}
传统的关系数据库从发明以来就是一个单机版系统，为了扩展数据库的读写能力，很多传统的关系型数据库系统支持复制。比如在mysql中，可以通过主从复制来扩展服务器的读取能力,如图\ref{pic5/jiagouzc}所示，在主从架构中，只有一个主服务器接受客户端的写请求，然后主节点传播这些更新请求到从服务器，从而达到每个服务器数据保持一致的状态。
传统关系数据库系统的复制分为物理复制和命令复制，物理复制就是把底层数据存储引擎的更改情况传播到其他的从节点。命令复制就只需要传播SQL命令到从节点再执行一下。主从数据就一样了。主从复制虽然能够提高数据库系统的读取能力，但是其不能扩展服务器的写能力，因为多个服务器同时写会引起数据不一致的问题。因为主从复制相对简单容易实现，大多数传统关系数据库系统都只支持主从架构。
\pic[htbp]{主从架构原理示意图}{}{pic5/jiagouzc}

在本论文所述分布式系统中，论文实现了多主复制架构
，该架构示意图如图\ref{pic5/jiagoudz}
所示，该架构和主从复制相比，不但能扩展数据库的读取能力，也能扩展数据库服务器的写能力，基本达到线性扩展的理想性能。
不但能提高分布式系统的读取能力，也能提高分布式系统的写性能。
\pic[htbp]{多主分布式架构原理图}{}{pic5/jiagoudz}

在分布式多主架构集群系统中，系统利用Hazelcast的多播节点自动发现功能，这样
就可以做到零配置分布式部署，当增加服务器的时候，新的服务器节点会自动加到已有的
分布式集群，在这个集群中，最先启动的服务器作为主节点，但主节点挂掉的时候，次启动的服务器代替主节点，如此循环，当服务器集群中只有一个服务器的时候，这个服务器就作为唯一的主节点。

\pic[htbp]{多主架构更新请求}{}{pic5/insertr}
在分布式多主架构中，系统的更新请求如图\ref{pic5/insertr}
所示。系统利用Hazelcast的分布式队列功能保存分布式系统的命令请求，当前服务器处理完成以后就直接返回给客户端，这样可以减少服务器系统的网络延迟，提高系统的性能。当其他服务器都返回成功消息以后，就会把这个命令请求从分布式队列里面删除，如图\ref{pic5/insertre}所示；
\pic[htbp]{多主架构更新成功图}{}{pic5/insertre}
当有服务器执行失败的时候，就会把当前命令放到一个恢复队列里面进行执行。

JSQL分布式系统选择逻辑复制，这样可以减少网络中数据的传输数量，减少客户端的等待时间，提高服务器的整体性能。在分布式架构实现中，主要有三个关键的类，其类结构定义如图\ref{pic5/jiagouleitu}所示。其中SqlUpdateLog作为数据库操作日志类，LSN为日志序列号，sql为操作命令语句，db为当前操作的逻辑数据库；ReplicationCMD对象为复制命令对象，当一个服务器节点启动的时候，如果其数据不是最新的，就需要发送复制命令给其他服务器，使得其数据可以和集群保存一致；MyHazelcast类图中的一些关键变量是实现分布式架构的基础，这些变量的作用后面会详细说明。在分布式数据库集群中，每个节点在启动的时候，都会经过初始化和命令执行两个阶段，下面对这两个阶段的实现流程进行说明。
\pic[htbp]{分布式架构相关类图}{}{pic5/jiagouleitu}
\subsection{集群初始化流程}
在每个服务器启动的时候，就会执行集群初始化。集群初始化流程如图
\ref{pic5/jiagoucsh}所示。
\pic[htbp]{集群初始化流程}{}{pic5/jiagoucsh}
根据集群初始化流程图，服务器初始化过程包括以下步骤：

第一，获取当前服务器节点的本地日志序列号locals\_maxlsn，locals\_maxlsn代表当前服务器本地存储引擎已经保存的最新数据的日志记录，通过logFile类可以得到当前服务器的本地日志序列号。如果当前服务器没有存储任何的数据，那么这个locals\_maxlsn就为零。

第二，获取当前集群的日志序列号iAtomic\_remote\_lsn,iAtomic\_remote\_lsn记录当前的集群最新的日志序列号。在获取集群日志序列号的过程中，如果当前服务器是最先启动的服务器，那么集群的日志序列号就还没有设置，当前服务器节点作为主节点，设置集群的日志序列号为当前服务器的本地序列号。在实现的过程中，用到了Hazelcast的分布式原子数据结构，能够保持分布式集群环境下，日志序列号数据的全局一致性。

第三，比较当前服务器的本地日志序列号locals
\_maxlsn和集群日志序列号iAtomic\_remote\_lsn,如果iAtomic\_remote\_lsn大于locals\_maxlsn，就设置变量isreplicating为true，表示当前服务器节点进入复制阶段。在复制阶段。只能执行复制命令。不能执行其他服务器节点接受到的客户端命令。当前节点需要从集群更新复制数据的时候，就向cmdQuene队列发送复制命令请求，集群中的服务器接受到这个命令请求以后，就通过iLockwrite锁来得到这个命令。这个命令请求的服务器节点就会把最新的数据发送给当前服务器节点。当前服务器节点更新数据完成以后。才进行远程队列数据的同步。

第四，在当前节点进入复制阶段以后，有可能会收到客户端的命令请求，或者是收到其他服务器节点的远程命令请求。但是在复制阶段，当前服务器不能执行客户端的命令请求，所以需要localquene保存接收到的命令请求。

第五，在第三步完成以后，服务器节点执行localquene里面的命令。所以步骤完成以后。当前服务器节点的数据就和集群中的数据保持一致了。以后就可以接收客户端的命令，直接执行，返回结果。也可以同步执行远程队列里面其他服务器发送过来的命令。
\subsection{集群命令执行过程}
当服务器启动的时候，就可以接受客户端的命令请求，但是只有在服务器初始化完成以后，才会对命令请求进行处理。每个服务器节点启动的时候有两个阶段：初始化阶段和复制阶段。在这两个阶段，都需要暂时保存接受到的客户端命令。一旦初始化完成以后，就可以对客户端的命令进行处理，具体处理流程如图\ref{pic5/jiagoucsh}所示。其具体的算法步骤如下：
\pic[htbp]{集群命令执行流程}{}{pic5/jiagouml}

\begin{enumerate}[fullwidth,itemindent=2em]
	\item 客户端通过负载均衡选择到了当前服务器，然后向当前服务器发送命令请求。判断当前服务器的状态，如果在复制阶段，则说明当前服务器节点正在初始化阶段，还不能执行命令。
	\item 当服务器处于复制状态的时候，需要获取集群的当前日志序列号，然后根据当前的日志序列号和命令请求，生成日志对象。暂时保持在本地队里面。待复制阶段完成以后，依次执行本地队列里面的命令请求。
	\item 如果当前服务器初始化已经完成，没有处于复制状态，那么说明本地数据和集群数据已经保持一致，可以执行命令。
	\item 本地日志序列号增加1，代表本地数据已经更新。
	\item 集群日志序列号增加1，向集群中所有的服务器节点广播，表示已经有新的数据更新。
	\item 当前服务器节点保存日志记录，已持久化数据存储，然后处理命令请求。返回数据给客户端。
	\item 发送日志记录到远程队列。其他服务器节点就可以通过远程队列来同步更新里面的数据记录。保持和当前服务器的数据一致性。
\end{enumerate}

该算法能够保证系统在多个节点同时更新的时候数据库系统数据的一致性，分布式数据库集群能够动态增加节点。当增加一个数据库节点的时候，不需要人为配置，系统能够自动发现，自动同步数据。这是MYSQL等传统数据库系统的复制架构所无法办到的事情。
\section{数据库基本功能实现}
数据库系统功能是分布式数据库节点中最重要的
功能模块，提供数据的更删改查等数据库最基本的功能。
在源代码实现里面，
SQL包下面的类主要是作为数据库系统管理类，
让用户启动数据库服务器或者关闭数据库服务器。
表\ref{codepdf/sql}描述了SQL包下每个类的作用。
\pictable[htbp]{SQL包的每个类的作用}{}{codepdf/sql}
其中SpringMain类是数据库系统功能的入口，这个类主要调用其他模块，完成数据库系统的启动。
ShutdownMain类用来关闭数据库系统。
按照客户端请求信息的处理流程，
数据库功能模块主要包括网络模块，SQL解析模块和存储引擎模块，
下面分别描述每个模块具体的实现。
\subsection{网络和协议模块}
在网络模块，处理网络套接字的连接和网络字节的处理。
在分布式数据库节点接收到客户端的套接字连接请求以后，
网络模块服务器端套接字接收请求，完成三次握手建立连接以后。交个Netty来处理。
网络字节处理模块主要是用了Netty来实现的，所有和网络字节处理有关的代码都在netty包下面。表\ref{codepdf/netty}描述了每个类的
功能。
\pictable[htbp]{网络模块中各个类的作用}{}{codepdf/netty}
在接收到客户端套接字连接以后，客户端信息会依次经过下面四个类的处理：
\begin{enumerate}
	\item ByteToMysqlDecoder
	\item ByteToMysqlPacket
	\item MysqlPacketHander
	\item NettyServer
\end{enumerate}
具体处理流程如图\ref{pic5/wangluo}所示。
\pic[htbp]{网络模块功能图}{}{pic5/wangluo}
网络模块收到客户端的套接字连接以后需要包网络字节包装成Mysql的消息包格式，如果错误就说明客户端不是我们的客户端或者客户端发送了其他的错误。当截取到消息包格式以后，还需要解析成我们的数据结构，如果解析成功就包数据结构发送到解析模块，如果解析错误，就断开连接。

除了实现网络模块以外，我们还要实现通信协议，系统
采用了和mysql一样的通信协议，在mysql包下面实现了mysql的通信协议。
表\ref{codepdf/mysql}给出了实现通信协议所用到的所有的类。
\pictable[htbp]{通信协议实现所用到的类}{}{codepdf/mysql}

网络服务器接受到客户端的连接以后，就要解析mysql的通信协议，
把每一个消息包封装到具体的对象里面，
% 表\ref{codepdf/mysqlmysql}描述了所有的mysql通信协议的封装对象。
%\pictable[htbp]{mysql所有协议包的封装对象}{}{codepdf/mysqlmysql}
mysql协议里面有很多的包，每个协议包都
需要一个类来实现，图\ref{pic5/woshou}是握手包的类图，
\pic[htbp]{握手包实现类图}{}{pic5/woshou}
其他包的实现大体相同，所以在这里不再重复说明。

解析到协议包以后我们就要对协议包进行处理，
协议包的主要有两个阶段，一个是认证阶段，一个是命令阶段，认证阶段就是
接受客户端的请求，然后检查用户的认证信息，比如用户名和密码，
图\ref{pic5/renzheng}显示了认证流程过程。
\pic[htbp]{认证流程图}{}{pic5/renzheng}
如果认证成功以后，就建立连接会话，然后客户端就可以进行向服务器发送命令请求向分布式数据库节点处理数据。
如果失败失败就返回给客户端失败原因。
认证成功以后就是命令阶段，服务器接受客户端的命令，然后处理，
图\ref{pic5/mingling}显示了命令处理流程。
\pic[htbp]{命令处理流程图}{}{pic5/mingling}
在接收到客户端的命令请求以后，网络模块就会调用下面模块的功能接口来对这个命令进行处理。
如果命令处理过程中没有发生异常，那么就把命令处理结果发送给客户端，如果命令处理工程中发送了异常，就返回失败原因。
\subsection{SQL解析模块}
经过网络模块的处理，我们建立了客户端的连接会话，接下来我们就要对客户端发送过来的命令进行判断，如果是SQL命令，就要对这个命令进行解析，进行词法分析，语法分析和语意检查。
在代码实现中，sql包下面的类主要完成对客户端连接和会话的封装和管理，表\ref{codepdf/jsqlsql}显示了sql包下面每个类的具体作用。
\pictable[htbp]{SQL前端连接模块相关的类}{}{codepdf/jsqlsql}
在sql解析功能模块里面系统用到了druid开源框架，用来解析sql，解析sql以后就要做具体的数据处理，
图\ref{pic5/sqlchuli}显示了SQL模块的处理流程图。
\pic[htbp]{SQL处理流程图}{}{pic5/sqlchuli}
在sql解析流程中，如果遇到Druid框架不支持的语句，我们就要自己对这个语句进行解析。再这个工程中。任何一个步骤发送错误就返回错误信息给客户端。不然就进行发送给下一个功能模块进行具体的数据操作。
mysql当中的sql语句有很多种，每一种语句都要做不同的处理。
%\ref{codepdf/sqljiexi}描述了sql模块下实现的各种类型的
%语句。
%\pictable[htbp]{SQL模块下实现的各种类型的语句}{}{codepdf/sqljiexi}
每一种类型语句下面又回有很多种具体语句的实现，表\ref{codepdf/sqlddm}给出了数据
操纵类型语句实现的所有相关的类和响应的功能。
其他类型的语句也需要进行相同的处理，这里就不再进行详细表述。
\pictable[htbp]{数据操纵数据实现所相关的类}{}{codepdf/sqlddm}
\subsection{存储引擎模块}
数据库引擎是一个数据库最关键的功能模块，其是决定系统性能的关键功能。
在mysql数据库系统中，有出名的插件式存储引擎，用户能够根据具体场景选择合适的存储引擎。
而在jsql中，选择了类似的方法，用户可以根据场景选择适合的非关系型存储引擎，比如OrientDB和elasticsearch，每种存储引擎适合用在不同的场景，这对于一个多模型的数据库来说非常重要。


存储引擎有关的功能主要在storage包下面实现，表\ref{codepdf/storage}给出了
storage包下面各种文件的功能。
\pictable[htbp]{storage包下面各种文件的作用}{}{codepdf/storage}
其中DB类作为底层存储引擎的接口，他的功能接口如表\ref{codepdf/db}所示。
\pictable[htbp]{数据库存储引擎的函数接口}{}{codepdf/db}
和表有关的功能接口如表\ref{codepdf/table}所示。
\pictable[htbp]{数据库引擎和表有关功能的接口}{}{codepdf/table}

存储引擎利用非关系型数据存储引擎，为上面模块提供操作接口。其中有关数据库操作的类接口如图\ref{pic5/db}b所示，有关表操作的类接口如图\ref{pic5/table}所示。
类的实现主要是封装了OrientDB等存储引擎的功能，为上一次提供关系操作的接口。在关系数据库中，操作接口就是SQL语言。JSQL因为选择了兼容Mysql协议，所以实现了大部分的Mysql语句功能。这样上层功能模块就可以当做Mysql一样的使用本数据库引擎。
\pic[htbp]{数据库操作接口类图}{}{pic5/db}
\pic[htbp]{表操作接口类图}{}{pic5/table}
\section{数据审计模块的实现}
JSQL除了结合关系数据库和非关系型数据库以外，还从数据库的底层考虑数据的安全问题，对数据审计功能进行了简单的实现，在代码实现中，
审计模块有关的功能全部在audit包下面实现，
表\ref{codepdf/audit}给出了audit包下面
每个类的具体的作用。
\pictable[htbp]{audit包下面每个类的作用}{}{codepdf/audit}
其中LoginLog和SQLlog类主要封装了两种日志类型，一种是客户端的登录记录日志，一种是客户端的命令执行日志。
通过封装这两种日志记录，很容易的就可以实现审计数据的收集和发送功能。
图\ref{pic5/shenji}显示了审计功能演示图。
\pic[htbp]{审计功能演示图}{}{pic5/shenji}
审计功能主要包括审计数据库，审计管理器和审计可视化功能模块，下面分别对每个模块进行说明
\begin{enumerate}[fullwidth,itemindent=2em,listparindent=2em]
	\item 审计数据库:
	审计数据库用Elasticsearch来实现，
	作为审计数据库，不能让用户随意的更改，
	所以本系统更改了它的源代码，使得它只能增加数据和查找数据
	不能更改和删除数据。其中主要存储的对象如图\ref{codepdf/audit}所示。
	\item 审计管理器:
	审计管理功能全部在audit下面实现，主要是存储本地的日志文件，
	然后发布到审计数据库。
	提供给前端可视化的接口。
	\item 审计可视化模块的实现:
	审计可视化模块的实现用到了grafana，
	主要用来监控ELK中的数据。管理员通过连接分布式管理节点可以对审计数据进行查询。从而对数据的更改情况进行掌控。
\end{enumerate}
\section{本章小结}
对系统进行详细设计以后就是编码阶段，分布式数据库系统JSQL完全采用JAVA语言开发，本章首先对系统代码的结构进行说明，然后给出系统设计阶段所划分的关键功能模块的实现，主要包括客户端功能模块、数据库功能模块和数据审计功能模块，对每个功能模块，通过流程图或者代码的方法描述其功能实现。本章重点对论文所用分布式负载均衡算法和多主分布式架构的实现进行了详细的阐述。